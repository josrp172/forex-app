<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holiday Magic Show</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&family=Mountains+of+Christmas:wght@700&family=Pacifico&family=Quicksand:wght@400;500;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --gold: #ffd700;
            --white: #ffffff;
            --red: #d63031;
            --green: #1a472a;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Fredoka', sans-serif;
            color: var(--white);
            user-select: none;
            transition: background 1.5s ease;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            perspective: 1200px;
            opacity: 0;
            /* Hidden by default for landscape viewing */
        }

        .photo-stage {
            position: relative;
            transform-style: preserve-3d;
            margin-bottom: 80px;
            animation: floatPanel 6s ease-in-out infinite;
        }

        @keyframes floatPanel {

            0%,
            100% {
                transform: translateY(0) rotateX(0deg);
            }

            50% {
                transform: translateY(-12px) rotateX(1deg);
            }
        }

        .photo-aura {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 320px;
            height: 320px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.4) 0%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            filter: blur(30px);
            z-index: 1;
            opacity: 0;
            pointer-events: none;
        }

        /* ============ GIFT BOX UNBOXING ELEMENTS ============ */
        .gift-box-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transform-style: preserve-3d;
            perspective: 1000px;
            z-index: 15;
        }

        .gift-box-base {
            position: absolute;
            top: -10px;
            left: -10px;
            width: 300px;
            height: 300px;
            /* Rich Velvet Red with fabric texture */
            background:
                linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                linear-gradient(180deg, #c0392b 0%, #96281b 50%, #7b1e16 100%);
            border-radius: 8px;
            z-index: 4;
            box-shadow:
                0 25px 60px rgba(0, 0, 0, 0.5),
                0 10px 30px rgba(0, 0, 0, 0.3),
                inset 0 2px 0 rgba(255, 255, 255, 0.15),
                inset 0 -5px 20px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transform-style: preserve-3d;
        }

        /* Box Front Face (visible depth) */
        .gift-box-base::before {
            content: '';
            position: absolute;
            bottom: -25px;
            left: 0;
            width: 100%;
            height: 25px;
            background: linear-gradient(180deg, #7b1e16 0%, #5a1510 100%);
            transform: rotateX(-90deg);
            transform-origin: top;
            border-radius: 0 0 6px 6px;
        }

        /* Golden Ribbon on Base - Vertical */
        .gift-box-base::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 0;
            width: 40px;
            height: 100%;
            background:
                linear-gradient(90deg, #b8860b 0%, #ffd700 25%, #fff8dc 50%, #ffd700 75%, #b8860b 100%);
            transform: translateX(-50%);
            box-shadow:
                inset 0 0 8px rgba(0, 0, 0, 0.2),
                0 0 15px rgba(255, 215, 0, 0.3);
        }

        /* Horizontal Ribbon on Base */
        .gift-ribbon-h {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 40px;
            background:
                linear-gradient(180deg, #b8860b 0%, #ffd700 25%, #fff8dc 50%, #ffd700 75%, #b8860b 100%);
            transform: translateY(-50%);
            box-shadow:
                inset 0 0 8px rgba(0, 0, 0, 0.2),
                0 0 15px rgba(255, 215, 0, 0.3);
            z-index: 2;
        }

        .gift-box-lid {
            position: absolute;
            top: -60px;
            left: -15px;
            width: 310px;
            height: 60px;
            /* Matching velvet with highlight */
            background:
                linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, transparent 40%),
                linear-gradient(180deg, #e74c3c 0%, #c0392b 40%, #96281b 100%);
            border-radius: 10px 10px 6px 6px;
            z-index: 20;
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.5),
                0 5px 15px rgba(0, 0, 0, 0.3),
                inset 0 3px 0 rgba(255, 255, 255, 0.2),
                inset 0 -2px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transform-style: preserve-3d;
        }

        /* Lid Side Face */
        .gift-box-lid::before {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 0;
            width: 100%;
            height: 15px;
            background: linear-gradient(180deg, #96281b 0%, #7b1e16 100%);
            transform: rotateX(-90deg);
            transform-origin: top;
            border-radius: 0 0 4px 4px;
        }

        /* Ribbon Cross on Lid */
        .gift-lid-ribbon-v {
            position: absolute;
            left: 50%;
            top: 0;
            width: 40px;
            height: 100%;
            background:
                linear-gradient(90deg, #b8860b 0%, #ffd700 25%, #fff8dc 50%, #ffd700 75%, #b8860b 100%);
            transform: translateX(-50%);
            z-index: 1;
        }

        .gift-lid-ribbon-h {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 20px;
            background:
                linear-gradient(180deg, #b8860b 0%, #ffd700 25%, #fff8dc 50%, #ffd700 75%, #b8860b 100%);
            transform: translateY(-50%);
            z-index: 1;
        }

        /* Luxurious 3D Bow */
        .gift-bow-container {
            position: absolute;
            top: -45px;
            left: 50%;
            transform: translateX(-50%) translateZ(30px);
            z-index: 30;
            filter: drop-shadow(0 8px 15px rgba(0, 0, 0, 0.4));
        }

        .gift-bow-loop {
            position: absolute;
            width: 50px;
            height: 35px;
            background: linear-gradient(135deg, #ffd700 0%, #fff8dc 40%, #ffd700 60%, #b8860b 100%);
            border-radius: 50% 50% 45% 45%;
            box-shadow:
                inset 0 -5px 10px rgba(0, 0, 0, 0.2),
                inset 0 5px 10px rgba(255, 255, 255, 0.3);
        }

        .gift-bow-loop.left {
            left: -40px;
            top: 10px;
            transform: rotate(-25deg);
        }

        .gift-bow-loop.right {
            right: -40px;
            top: 10px;
            transform: rotate(25deg);
        }

        .gift-bow-center {
            position: relative;
            width: 30px;
            height: 25px;
            background: radial-gradient(ellipse at 30% 30%, #fff8dc, #ffd700 40%, #b8860b 100%);
            border-radius: 30%;
            box-shadow:
                0 3px 8px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.4);
            z-index: 5;
        }

        .gift-bow-tail {
            position: absolute;
            width: 18px;
            height: 55px;
            background: linear-gradient(180deg, #ffd700 0%, #b8860b 50%, #8b6914 100%);
            border-radius: 0 0 8px 8px;
            top: 15px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
        }

        .gift-bow-tail.left {
            left: -12px;
            transform: rotate(15deg);
        }

        .gift-bow-tail.right {
            right: -12px;
            transform: rotate(-15deg);
        }

        /* Shimmer Animation for Ribbons */
        @keyframes ribbonShimmer {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        .gift-box-base::after,
        .gift-ribbon-h,
        .gift-lid-ribbon-v,
        .gift-lid-ribbon-h {
            background-size: 200% 100%;
            animation: ribbonShimmer 3s ease-in-out infinite;
        }

        /* Inner Glow when opening */
        .gift-inner-glow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(255, 215, 0, 0.8) 0%, rgba(255, 255, 255, 0.4) 30%, transparent 70%);
            border-radius: 8px;
            opacity: 0;
            z-index: 3;
            pointer-events: none;
        }

        .photo-container {
            width: 280px;
            height: 280px;
            border: none;
            border-radius: 12px;
            box-shadow:
                0 25px 60px rgba(0, 0, 0, 0.6),
                0 0 40px rgba(255, 215, 0, 0.15),
                inset 0 0 60px rgba(255, 255, 255, 0.1);
            overflow: visible;
            background: linear-gradient(145deg, rgba(139, 90, 43, 0.9), rgba(101, 67, 33, 0.95));
            position: relative;
            z-index: 5;
            padding: 12px;
            transform-style: preserve-3d;
        }

        /* 3D Carved Wood Frame Effect */
        .photo-container::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 12px;
            background: linear-gradient(145deg,
                    rgba(205, 133, 63, 0.4) 0%,
                    rgba(139, 90, 43, 0.2) 50%,
                    rgba(101, 67, 33, 0.6) 100%);
            border: 3px solid rgba(255, 215, 0, 0.4);
            box-shadow:
                inset 2px 2px 4px rgba(255, 255, 255, 0.2),
                inset -2px -2px 4px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        /* Gold Leaf Inner Border */
        .photo-container::after {
            content: '';
            position: absolute;
            inset: 8px;
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-radius: 8px;
            box-shadow:
                0 0 10px rgba(255, 215, 0, 0.3),
                inset 0 0 10px rgba(255, 215, 0, 0.2);
            pointer-events: none;
        }

        /* Snow Accumulation on Frame Top */
        .frame-snow {
            position: absolute;
            top: -8px;
            left: 10%;
            width: 80%;
            height: 16px;
            background: radial-gradient(ellipse at center bottom,
                    rgba(255, 255, 255, 0.95) 0%,
                    rgba(240, 248, 255, 0.8) 40%,
                    transparent 70%);
            border-radius: 50% 50% 0 0;
            filter: blur(1px);
            z-index: 10;
        }

        .photo-inner {
            width: 100%;
            height: 100%;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
        }

        .photo-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: blur(45px) contrast(1.1) brightness(1.2);
            transform: scale(1.1);
        }

        .photo-glint {
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.6), transparent);
            transform: skewX(-25deg);
            z-index: 5;
        }

        .deco {
            position: absolute;
            font-size: 3.5rem;
            filter: drop-shadow(0 10px 10px rgba(0, 0, 0, 0.4));
            z-index: 10;
            opacity: 0;
            transform: scale(0);
        }

        /* ============ GLASS-MORPHISM MESSAGE PANEL ============ */
        .text-wrap {
            /* Frosted Glass Effect */
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.15) 0%,
                    rgba(255, 255, 255, 0.08) 50%,
                    rgba(200, 220, 255, 0.12) 100%);
            backdrop-filter: blur(20px) saturate(1.2);
            -webkit-backdrop-filter: blur(20px) saturate(1.2);

            color: var(--white);
            padding: 45px 65px;
            border-radius: 24px;

            /* Ice Edge Effect - subtle inner glow */
            border: 0.5px solid rgba(255, 255, 255, 0.4);
            box-shadow:
                0 30px 80px rgba(0, 0, 0, 0.5),
                0 0 1px rgba(255, 255, 255, 0.8),
                inset 0 0 30px rgba(255, 255, 255, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);

            text-align: center;
            max-width: 85%;
            min-width: 420px;
            opacity: 0;
            display: flex;
            flex-direction: column;
            gap: 18px;
            position: relative;
            overflow: hidden;
            animation: floatPanel 6s ease-in-out infinite;
            animation-delay: 0.5s;
        }

        /* Shimmer overlay for magical effect */
        .text-wrap::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.15),
                    transparent);
            animation: panelShimmer 8s ease-in-out infinite;
        }

        @keyframes panelShimmer {

            0%,
            100% {
                left: -100%;
            }

            50% {
                left: 150%;
            }
        }

        .main-msg {
            font-family: 'Mountains of Christmas', cursive;
            font-size: 2.4rem;
            display: inline-block;
            min-height: 2.8rem;
            color: #fff;
            text-shadow:
                0 2px 10px rgba(0, 0, 0, 0.4),
                0 0 30px rgba(255, 215, 0, 0.3);
            letter-spacing: 1px;
        }

        .sub-msg {
            font-family: 'Quicksand', sans-serif;
            font-size: 1.15rem;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
            display: inline-block;
            min-height: 1.6rem;
            line-height: 1.7;
            text-shadow: 0 1px 8px rgba(0, 0, 0, 0.3);
        }

        /* Sparkle particle container for typewriter effect */
        #sparkle-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            overflow: hidden;
        }

        .sparkle-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #ffd700 0%, #ffaa00 50%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            animation: sparkleFloat 1.2s ease-out forwards;
        }

        @keyframes sparkleFloat {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translate(var(--dx), var(--dy)) scale(0);
            }
        }

        /* ============ FINALE TRANSITION EFFECTS ============ */
        .finale-magic {
            position: absolute;
            pointer-events: none;
            z-index: 2005;
        }

        .particle-firework {
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, #fff 0%, #ffd700 40%, #ff8800 100%);
            border-radius: 50%;
            box-shadow: 0 0 15px #ffd700, 0 0 30px #ffaa00;
        }

        .particle-snow-burst {
            width: 8px;
            height: 8px;
            background: #fff;
            border-radius: 50%;
            filter: blur(1px);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        #finale-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 3000;
            pointer-events: none;
            opacity: 0;
        }





        /* Cursor for typing effect */
        .typing-cursor {
            border-right: 3px solid var(--red);
            animation: blink 0.7s infinite;
        }

        @keyframes blink {

            0%,
            100% {
                border-color: transparent;
            }

            50% {
                border-color: var(--red);
            }
        }

        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            /* Above the book overlay */
            background: transparent;
            /* Show the book underneath */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            perspective: 500px;
            /* For 3D text effects */
        }

        /* HERO TITLE: Holiday Express */
        #start-overlay h1 {
            font-family: 'Mountains of Christmas', cursive;
            font-size: 6rem;
            /* Much Bigger */
            margin: 0 0 10px 0;
            color: #ffffff;
            text-shadow:
                0 0 10px rgba(255, 215, 0, 0.5),
                0 0 30px rgba(255, 215, 0, 0.3),
                0 10px 40px rgba(0, 0, 0, 0.8);
            transform: translateZ(50px);
            letter-spacing: 2px;
            animation: heroFloat 6s ease-in-out infinite;
        }

        @keyframes heroFloat {

            0%,
            100% {
                transform: translateY(0) translateZ(50px);
            }

            50% {
                transform: translateY(-10px) translateZ(50px);
            }
        }

        /* CINEMATIC TAGLINE */
        .cinematic-sub {
            font-size: 1.4rem;
            margin-bottom: 60px;
            font-weight: 400;
            letter-spacing: 8px;
            /* High spacing */
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            text-transform: uppercase;
        }

        .hint-text {
            margin-top: 25px;
            font-family: 'Fredoka', sans-serif;
            font-size: 0.9rem;
            color: rgba(255, 215, 0, 0.7);
            letter-spacing: 1px;
            opacity: 0;
            animation: fadeInHint 2s ease-out forwards 1s;
        }

        @keyframes fadeInHint {
            to {
                opacity: 1;
            }
        }

        /* Wax Seal Button with Strings */
        .seal-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .seal-string {
            position: absolute;
            height: 4px;
            /* Twisted Twine Look */
            background: repeating-linear-gradient(45deg, #8B0000, #8B0000 5px, #5a0000 5px, #5a0000 10px);
            top: 50%;
            transform: translateY(-50%);
            z-index: -1;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        /* Festive Curls/Hair strings */
        .seal-curl {
            position: absolute;
            border: 1px solid #8B0000;
            border-radius: 50%;
            pointer-events: none;
            z-index: -2;
            opacity: 0.6;
            animation: curlSway 6s infinite ease-in-out alternate;
        }

        @keyframes curlSway {
            0% {
                transform: rotate(0deg) scale(1);
            }

            100% {
                transform: rotate(15deg) scale(1.1);
            }
        }

        .seal-string-left {
            right: 50%;
            width: 50vw;
            border-radius: 3px 0 0 3px;
        }

        .seal-string-right {
            left: 50%;
            width: 50vw;
            border-radius: 0 3px 3px 0;
        }

        .play-btn {
            background: radial-gradient(circle at 35% 35%, #b21e1e, #5a0909);
            color: #ffca28;
            /* Brighter gold */
            border: none;
            cursor: pointer;
            /* Authentic "Melted" Wax Shape */
            border-radius: 48% 52% 51% 49% / 54% 45% 55% 46%;
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.8),
                inset 0 0 15px rgba(0, 0, 0, 0.5),
                /* Inner shadow for depth */
                inset 0 0 0 8px #9b1c1c;
            /* The outer rim/lip of the wax seal */
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto;
            position: relative;
            z-index: 10;
            width: 150px;
            height: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            animation: sealBreath 6s infinite ease-in-out;
        }

        /* Dramatic Breathing & Shimmer */
        @keyframes sealBreath {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1) drop-shadow(0 0 0px rgba(255, 215, 0, 0));
            }

            50% {
                transform: scale(1.05);
                filter: brightness(1.1) drop-shadow(0 0 15px rgba(255, 215, 0, 0.3));
            }
        }

        .play-btn::after {
            /* Gold Sparkle Rim pulsing */
            content: "";
            position: absolute;
            top: -5px;
            bottom: -5px;
            left: -5px;
            right: -5px;
            border-radius: 50%;
            border: 1px solid rgba(255, 215, 0, 0.3);
            opacity: 0;
            animation: rimFlash 5s infinite;
        }

        @keyframes rimFlash {
            40% {
                opacity: 0;
                transform: scale(1);
            }

            50% {
                opacity: 0.8;
                transform: scale(1.1);
            }

            60% {
                opacity: 0;
                transform: scale(1);
            }
        }

        .play-btn::before {
            content: "üîí";
            font-size: 1.5rem;
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.4));
            margin-bottom: 2px;
            display: block;
        }

        @keyframes sealGlow {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.02);
                filter: brightness(1.15);
            }
        }

        .play-btn:hover {
            transform: scale(1.08) rotate(-3deg);
            filter: brightness(1.1);
        }

        .seal-text {
            font-size: 0.95rem;
            font-family: 'Fredoka', sans-serif;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-weight: 600;
            color: #ffd700;
            text-align: center;
            max-width: 100px;
            line-height: 1.2;
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.8);
        }

        .timer-line {
            position: fixed;
            top: 0;
            left: 0;
            height: 8px;
            background: linear-gradient(to right, var(--gold), #fff, var(--gold));
            width: 0%;
            z-index: 60;
            box-shadow: 0 0 15px var(--gold);
        }

        .countdown-box {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 50;
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-size: 1.1rem;
            display: none;
            align-items: center;
            gap: 10px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }

        .countdown-box span {
            font-weight: 700;
            font-size: 1.4rem;
            color: var(--gold);
        }

        .scene-indicator {
            position: fixed;
            bottom: 35px;
            right: 45px;
            z-index: 50;
            background: transparent;
            padding: 0;
            font-family: 'Quicksand', sans-serif;
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.6);
            border: none;
            box-shadow: none;
            display: none;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 1px 5px rgba(0, 0, 0, 0.5);
        }

        /* Storybook Transition */
        #book-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 500;
            pointer-events: none;
            display: flex;
            visibility: visible;
            perspective: 2000px;
            animation: bookBreathing 8s infinite ease-in-out;
        }

        /* Spine with stitching & LIGHT SWEEP */
        #book-spine {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 20px;
            transform: translateX(-50%);
            background: linear-gradient(90deg, #3d0a0a, #5a1010, #3d0a0a);
            z-index: 15;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        #book-spine::after {
            content: "";
            position: absolute;
            top: -50%;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(to bottom, transparent, rgba(255, 215, 0, 0.4), transparent);
            filter: blur(4px);
            animation: spineSweep 6s infinite ease-in-out;
        }

        @keyframes spineSweep {
            0% {
                top: -50%;
                opacity: 0;
            }

            30% {
                opacity: 1;
            }

            60% {
                top: 150%;
                opacity: 0;
            }

            100% {
                top: 150%;
                opacity: 0;
            }
        }

        /* Center Sparkle at intersection */
        .intersection-sparkle {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, #fff 0%, rgba(255, 215, 0, 0.8) 20%, transparent 70%);
            z-index: 12;
            /* Between seal and spine/string */
            mix-blend-mode: screen;
            filter: blur(2px);
            animation: sparklePulse 3s infinite alternate;
        }

        @keyframes sparklePulse {
            0% {
                opacity: 0.3;
                scale: 0.8;
            }

            100% {
                opacity: 0.8;
                scale: 1.2;
            }
        }

        #book-spine-glow {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 10px;
            transform: translateX(-50%);
            background: radial-gradient(ellipse at center, var(--gold), transparent 70%);
            filter: blur(8px);
            z-index: 5;
            opacity: 0;
            box-shadow: 0 0 40px var(--gold);
        }

        @keyframes bookBreathing {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.015);
            }

            /* Very subtle scale pulse */
        }

        /* Subtle Floating Dust/Sparkles for Home */
        #intro-sparkles {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            overflow: hidden;
        }

        .dust,
        .snowflake-intro {
            position: absolute;
            background: white;
            border-radius: 50%;
            opacity: 0.3;
            filter: blur(2px);
            pointer-events: none;
        }

        .dust {
            animation: floatDust 20s infinite linear;
        }

        .snowflake-intro {
            animation: fallIntro 18s infinite linear;
            opacity: 0.4;
        }

        @keyframes floatDust {
            100% {
                transform: translate(100px, -100px) scale(0.5);
                opacity: 0;
            }
        }

        .book-page {
            flex: 1;
            height: 100%;
            background: #5a1010;
            background-image:
                linear-gradient(180deg, rgba(0, 0, 0, 0.2) 0%, transparent 15%, transparent 85%, rgba(0, 0, 0, 0.3) 100%),
                radial-gradient(ellipse at 30% 30%, rgba(255, 255, 255, 0.08) 0%, transparent 50%),
                url("https://www.transparenttextures.com/patterns/leather.png");
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow:
                inset 0 0 180px rgba(0, 0, 0, 0.95),
                /* Deeper vignette */
                inset 0 0 450px rgba(0, 0, 0, 0.6);
            border: 5px solid #8B5A2B;
            border-image: linear-gradient(145deg, #d4af37, #8B5A2B, #d4af37) 1;
        }

        /* Gold embossed inner frame */
        .book-page::before {
            content: "";
            position: absolute;
            /* Gold embossed border */
            pointer-events: none;
            box-shadow: 0 0 10px rgba(183, 139, 5, 0.3);
        }

        /* Gold Corner Protectors */
        .book-corner {
            position: absolute;
            width: 50px;
            height: 50px;
            z-index: 20;
        }

        .book-corner::before,
        .book-corner::after {
            content: "";
            position: absolute;
            background: linear-gradient(135deg, #ffd700, #b8860b);
        }

        .book-corner::before {
            width: 100%;
            height: 4px;
        }

        .book-corner::after {
            width: 4px;
            height: 100%;
        }

        .corner-tl {
            top: 10px;
            left: 10px;
        }

        .corner-tr {
            top: 10px;
            right: 10px;
            transform: scaleX(-1);
        }

        .corner-bl {
            bottom: 10px;
            left: 10px;
            transform: scaleY(-1);
        }

        .corner-br {
            bottom: 10px;
            right: 10px;
            transform: scale(-1);
        }

        /* Gold Corners with Sway */
        .book-page::after {
            content: "‚öú";
            position: absolute;
            color: #d4af37;
            font-size: 2rem;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            animation: ornamentSway 4s infinite ease-in-out;
        }

        @keyframes ornamentSway {

            0%,
            100% {
                transform: rotate(0deg);
            }

            50% {
                transform: rotate(5deg);
            }
        }

        .book-left::after {
            bottom: 25px;
            left: 25px;
        }

        .book-right::after {
            bottom: 25px;
            right: 25px;
            transform: scaleX(-1);
        }

        .book-left::after {
            animation-delay: 0s;
        }

        .book-right::after {
            animation-delay: 1s;
        }

        .book-left {
            transform-origin: left;
        }

        .book-right {
            transform-origin: right;
        }

        .book-ornament {
            font-size: 5rem;
            opacity: 0.2;
            color: var(--gold);
            filter: grayscale(1) brightness(2);
            animation: ornamentSway 5s infinite ease-in-out alternate;
        }

        .shimmer-text {
            background: linear-gradient(90deg, #ffd700, #fff, #ffd700);
            background-size: 200% auto;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmerEffect 4s linear infinite;
        }

        @keyframes shimmerEffect {
            to {
                background-position: 200% center;
            }
        }

        .chapter-text {
            position: absolute;
            font-family: 'Mountains of Christmas', cursive;
            font-size: 3rem;
            color: var(--gold);
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            z-index: 10;
            opacity: 0;
            /* Hidden by default to avoid overlap with Start UI */
        }

        .hud {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 50;
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .hud-btn {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.4);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.4rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: 0.3s;
        }

        .hud-btn:hover {
            background: var(--red);
            border-color: white;
            transform: scale(1.1) rotate(5deg);
        }

        /* Start Overlay Title Hierarchy */
        #start-overlay h1 {
            font-family: 'Pacifico';
            font-size: 3.8rem;
            margin-bottom: 10px;
            color: white;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .cinematic-sub {
            font-size: 1.3rem;
            margin-bottom: 50px;
            font-weight: 300;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.8);
        }

        .hint-text {
            font-family: 'Fredoka', sans-serif;
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 30px;
            opacity: 0;
            animation: fadeInHint 2s ease-out forwards 2s;
        }

        /* Book Cover Title Subtle */
        #book-cover-title {
            position: absolute;
            top: 15%;
            width: 100%;
            text-align: center;
            z-index: 20;
            pointer-events: none;
            opacity: 1;
            /* More visible */
            transform: scale(1);
            transition: opacity 1s ease-in-out, transform 1s ease-in-out;
        }

        #book-cover-title .shimmer-text {
            font-family: 'Mountains of Christmas';
            font-size: 3.5rem;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.9);
            color: #ffd700;
            letter-spacing: 2px;
        }

        #book-cover-title div:last-child {
            font-size: 1rem;
            color: rgba(255, 215, 0, 0.8);
            letter-spacing: 8px;
            margin-top: 8px;
            text-transform: uppercase;
            font-weight: 700;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.7);
        }
    </style>
</head>

<body>
    <div id="finale-flash"></div>
    <div id="finale-magic-container"
        style="position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:2004;"></div>
    <div id="canvas-container"></div>
    <div id="ui-layer">
        <div class="photo-stage" id="photo-stage">
            <div class="photo-aura" id="photo-aura"></div>
            <!-- Enhanced 3D Gift Box for Realistic Unboxing -->
            <div id="gift-base" class="gift-box-base">
                <div class="gift-ribbon-h"></div>
                <div class="gift-inner-glow" id="gift-glow"></div>
            </div>
            <div id="gift-lid" class="gift-box-lid">
                <div class="gift-lid-ribbon-v"></div>
                <div class="gift-lid-ribbon-h"></div>
                <!-- 3D Bow -->
                <div class="gift-bow-container" id="gift-bow">
                    <div class="gift-bow-loop left"></div>
                    <div class="gift-bow-loop right"></div>
                    <div class="gift-bow-tail left"></div>
                    <div class="gift-bow-tail right"></div>
                    <div class="gift-bow-center"></div>
                </div>
            </div>
            <div class="deco" id="deco-1" style="top: -50px; left: -50px;">üéÅ</div>
            <div class="deco" id="deco-2" style="top: -50px; right: -50px;">üéÄ</div>
            <div class="deco" id="deco-3" style="bottom: -60px; left: 50%; transform: translateX(-50%);">‚ú®</div>
            <div class="photo-container" id="photo-box">
                <div class="frame-snow"></div>
                <div class="photo-inner">
                    <div class="photo-glint" id="photo-glint"></div>
                    <img src="{{ url_for('christmas.static', filename='avatar_true.jpg') }}" class="photo-img"
                        id="photo-img">
                </div>
            </div>
        </div>
        <div id="sparkle-container"></div>
        <div class="text-wrap" id="text-node">
            <div class="main-msg" id="msg-title"></div>
            <div class="sub-msg" id="msg-sub"></div>
        </div>
    </div>
    <div id="start-overlay">
        <h1 class="cinematic-title">Holiday Express</h1>
        <p class="cinematic-sub">A 3D Cinematic Journey</p>

        <div class="seal-container">
            <!-- Center Sparkle for Magic -->
            <div class="intersection-sparkle"></div>

            <div class="seal-string seal-string-left"></div>
            <div class="seal-string seal-string-right"></div>

            <!-- Decorative "Hair" Curls -->
            <div class="seal-curl"
                style="width: 40px; height: 20px; left: -60px; top: -10px; border-bottom: 2px solid #8B0000; border-radius: 40% 60%;">
            </div>
            <div class="seal-curl"
                style="width: 30px; height: 40px; left: -40px; bottom: -20px; border-left: 2px solid #8B0000; border-radius: 60% 40%;">
            </div>
            <div class="seal-curl"
                style="width: 50px; height: 15px; right: -70px; top: 10px; border-top: 2px solid #8B0000; border-radius: 50% 50%;">
            </div>
            <div class="seal-curl"
                style="width: 25px; height: 35px; right: -30px; bottom: -15px; border-right: 2px solid #8B0000; border-radius: 30% 70%;">
            </div>

            <button class="play-btn" id="go-btn">
                <span class="seal-text">Open Just<br>For You</span>
            </button>
        </div>
        <div class="hint-text">‚ú® A short cinematic experience awaits ‚ú®</div>
    </div>
    <div class="countdown-box" id="countdown-box">‚ú® <span id="countdown-timer">1:40</span></div>
    <div class="scene-indicator" id="scene-indicator">Page <span id="current-scene">1</span> / <span
            id="total-scenes">5</span></div>
    <div class="timer-line" id="timer"></div>
    <div id="book-overlay">
        <!-- Book Spine -->
        <div id="book-spine"></div>

        <!-- Ornate Clasp -->
        <div id="book-clasp">üîí</div>

        <!-- Ribbon Bookmark -->
        <div id="book-ribbon"></div>

        <!-- The Spine Glow (the "Thrill" leaking out) -->
        <div id="book-spine-glow"></div>

        <!-- Floating Discreet Dust -->
        <div id="intro-sparkles">
            <div class="dust" style="top: 20%; left: 10%; width: 5px; height: 5px; animation-duration: 25s;"></div>
            <div class="dust" style="top: 60%; left: 30%; width: 8px; height: 8px; animation-duration: 18s;"></div>
            <div class="dust" style="top: 40%; left: 80%; width: 4px; height: 4px; animation-duration: 22s;"></div>
            <div class="dust" style="top: 70%; left: 70%; width: 6px; height: 6px; animation-duration: 30s;"></div>
        </div>

        <!-- Decoration for the cover -->
        <div id="book-cover-title"
            style="position: absolute; top: 15%; width: 100%; text-align: center; z-index: 20; pointer-events: none; opacity: 0.7; transform: scale(0.9);">
            <div class="shimmer-text"
                style="font-family: 'Mountains of Christmas'; font-size: 3rem; text-shadow: 0 2px 10px rgba(0,0,0,0.6); color: #b8860b;">
                The Magic of Christmas</div>
            <div
                style="font-size: 0.9rem; color: rgba(255,215,0,0.5); letter-spacing: 6px; margin-top: 5px; text-transform: uppercase;">
                A
                Holiday Keepsake</div>
        </div>

        <div class="book-page book-left" id="book-l">
            <div class="book-ornament">üéÑ</div>
            <div class="chapter-text" id="book-text-l" style="right: 20px;">A Holiday Tale</div>
        </div>
        <div class="book-page book-right" id="book-r">
            <div class="book-ornament">‚ú®</div>
            <div class="chapter-text" id="book-text-r" style="left: 20px;">Just For You ‚ú®</div>
        </div>
        <!-- Finale Message (Hidden until end) -->
        <div id="finale-msg"
            style="position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; opacity: 0; pointer-events: none; text-align: center; padding: 40px;">
            <h1
                style="font-family: 'Mountains of Christmas', cursive; font-size: 5rem; color: var(--gold); margin-bottom: 20px; text-shadow: 0 5px 15px rgba(0,0,0,0.5);">
                Merry Christmas!</h1>
            <p style="font-family: 'Pacifico', cursive; font-size: 2.5rem; color: white;">& Advance Happy New Year!</p>
        </div>
    </div>
    <audio id="bgm" loop>
        <source src="{{ url_for('christmas.static', filename='Winter Book.mp3') }}" type="audio/mpeg">
    </audio>



    <!-- Module Import Map for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    <!-- GSAP remains global -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script type="module">
        import * as THREE from 'three';
        // Make THREE global for our existing code structure
        window.THREE = THREE;

        (function () {
            const DURATION = 20; // UPDATED: Last 20 seconds
            const script = [
                // Scene 1: INTRO - The Warm Welcome
                {
                    bg: "#1a472a",
                    title: "‚ú® To Someone Special ‚ú®",
                    sub: "This isn't just a greeting... it's a little piece of my heart, wrapped in winter magic, just for you.",
                    decos: ["üíù", "üåü", "‚ùÑÔ∏è"],
                    charPose: "wave",
                    camTarget: { x: 0, y: 4, z: 22 }
                },
                // Scene 2: RISING ACTION - Reflecting on the Journey
                {
                    bg: "#0c1445",
                    title: "üåô Looking Back at This Year üåô",
                    sub: "We've been through so much together... the laughter, the struggles, the little moments that meant everything.",
                    decos: ["‚≠ê", "üåô", "üí´"],
                    charPose: "lookup",
                    camTarget: { x: -3, y: 3, z: 20 }
                },
                // Scene 3: THE GIFT - Climax of Joy
                {
                    bg: "#5a2a2a",
                    title: "üéÅ A Special Gift for You üéÅ",
                    sub: "Just like these presents, my love for you is full of beautiful surprises. You are the best gift I've ever received.",
                    decos: ["üéÅ", "üíù", "‚ú®"],
                    charPose: "dance",
                    camTarget: { x: 4, y: 3, z: 21 }
                },
                // Scene 4: RESOLUTION - Comfort and Warmth
                {
                    bg: "#2d3436",
                    title: "üè† You Are My Home üè†",
                    sub: "No matter where life takes us, my heart will always find its way back to you. Always.",
                    decos: ["‚òï", "ü§ó", "üî•"],
                    charPose: "sit",
                    camTarget: { x: 0, y: 2, z: 18 }
                },
                // Scene 5: ENDING - Hope and Promise
                {
                    bg: "#b78b05",
                    title: "üåÖ Here's to Forever üåÖ",
                    sub: "May this new year bring you all the joy, love, and dreams your beautiful heart deserves. I'll be right here, cheering you on.",
                    decos: ["ü•Ç", "üéÜ", "üíõ"],
                    charPose: "bow",
                    camTarget: { x: 0, y: 5, z: 24 }
                }
            ];

            const TOTAL_TIME = script.length * DURATION;
            let timeRemaining = TOTAL_TIME, countdownInterval = null;
            let appState = { idx: -1, isPlaying: false };
            // Declare as window properties to ensure global accessibility and fix ReferenceError
            window.scene = null; window.camera = null; window.renderer = null;
            let elf, christmasTree, snowman, presents = [], props = {}, clock;
            let trees = [];

            function startChapterTimer() {
                if (countdownInterval) clearInterval(countdownInterval);
                countdownInterval = setInterval(updateCountdown, 1000);

                gsap.killTweensOf('#timer');
                gsap.fromTo('#timer', { width: "0%" }, { width: "100%", duration: DURATION, ease: "linear" });

                // Clear any existing delayed calls for nextScene
                gsap.killTweensOf(nextScene);
                gsap.delayedCall(DURATION, nextScene);
            }

            // Old Book Dust Emitter
            function emitBookDust() {
                const container = document.getElementById('finale-magic-container'); // Reuse container
                if (!container) return;
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;

                // Increase count for more visible dust
                for (let i = 0; i < 150; i++) {
                    const dust = document.createElement('div');
                    const size = Math.random() * 6 + 2; // Varying sizes 2px to 8px

                    dust.style.position = 'absolute';
                    dust.style.width = size + 'px';
                    dust.style.height = size + 'px';

                    // Mix of colors for texture: tan, white-ish, and dark dust
                    const colorVars = ['#d2b48c', '#f5deb3', '#a0522d', '#ffffff'];
                    dust.style.background = colorVars[Math.floor(Math.random() * colorVars.length)];

                    dust.style.borderRadius = '50%';
                    // Higher start opacity
                    dust.style.opacity = Math.random() * 0.6 + 0.4;
                    // Stronger glow
                    dust.style.boxShadow = '0 0 8px rgba(210, 180, 140, 0.6)';

                    container.appendChild(dust);

                    // Scatter dynamics
                    const angle = Math.random() * Math.PI * 2;
                    const force = Math.random() * 800 + 100; // Wider spread

                    gsap.set(dust, { x: centerX, y: centerY, scale: 0, rotation: Math.random() * 360 });

                    gsap.to(dust, {
                        x: centerX + Math.cos(angle) * force,
                        y: centerY + Math.sin(angle) * force * 0.6, // Elliptical spread
                        rotation: Math.random() * 360,
                        scale: Math.random() * 1.5 + 0.5,
                        opacity: 0,
                        duration: 2 + Math.random() * 2, // Slower fade
                        ease: "power2.out",
                        onComplete: () => dust.remove()
                    });
                }
            }

            // Sparkle particle emitter for typewriter effect
            function emitSparkles(x, y, count = 3) {
                const container = document.getElementById('sparkle-container');
                if (!container) return;

                for (let i = 0; i < count; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle-particle';

                    // Random direction
                    const dx = (Math.random() - 0.5) * 40;
                    const dy = -20 - Math.random() * 30;

                    sparkle.style.left = x + 'px';
                    sparkle.style.top = y + 'px';
                    sparkle.style.setProperty('--dx', dx + 'px');
                    sparkle.style.setProperty('--dy', dy + 'px');
                    sparkle.style.animationDelay = (i * 0.1) + 's';

                    container.appendChild(sparkle);

                    // Auto remove after animation
                    setTimeout(() => sparkle.remove(), 1500);
                }
            }

            function typeWriter(element, text, speed, callback) {
                element.innerHTML = '';
                let i = 0;

                function type() {
                    if (i < text.length) {
                        const char = text.charAt(i);
                        element.innerHTML += char;

                        // Emit sparkles for non-space characters (every 2nd char to reduce particles)
                        if (char !== ' ' && i % 2 === 0) {
                            const rect = element.getBoundingClientRect();
                            // Approximate position of the last character
                            const charWidth = rect.width / Math.max(1, element.textContent.length);
                            const x = rect.left + (i * charWidth * 0.8);
                            const y = rect.top + rect.height / 2;
                            emitSparkles(x, y, 2);
                        }

                        i++;
                        setTimeout(type, speed);
                    } else if (callback) {
                        callback();
                    }
                }
                type();
            }

            function updateCountdown() {
                if (timeRemaining <= 0) { clearInterval(countdownInterval); return; }
                timeRemaining--;
                const mins = Math.floor(timeRemaining / 60), secs = timeRemaining % 60;
                document.getElementById('countdown-timer').innerText = `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            function init3D() {
                if (typeof THREE === 'undefined') { alert('Three.js failed. Please refresh.'); return; }
                clock = new THREE.Clock();
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x1a472a, 0.025);

                camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
                window.cameraGroup = new THREE.Group();
                cameraGroup.add(camera);
                cameraGroup.position.set(0, 5, 22);
                scene.add(cameraGroup);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);


                // -------------------------------

                scene.add(new THREE.AmbientLight(0xffffff, 0.35));
                const mainLight = new THREE.DirectionalLight(0xfff8e0, 1.1);
                mainLight.position.set(8, 20, 10);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.set(2048, 2048);
                mainLight.shadow.camera.near = 1; mainLight.shadow.camera.far = 60;
                scene.add(mainLight);

                const fillLight = new THREE.PointLight(0xff8866, 0.6, 25);
                fillLight.position.set(-8, 4, 6);
                scene.add(fillLight);

                const rimLight = new THREE.PointLight(0x88ccff, 0.5, 20);
                rimLight.position.set(6, 3, -8);
                scene.add(rimLight);

                createGround();
                createForest();
                createSnowman();
                createPresents();
                createElf();
                createSparkles();
                createSnow();
                createStars();
                createSleigh();
                createCandyCanes();
                createAurora();

                // NEW: More Life Elements
                createFloatingLanterns();
                createBunnies();
                createFireflies();
                createFlyingOwls();
                createGroundDecor();

                // Scene Characters
                createPuppy();
                createSanta();
                createGingerbread();
                createFamily();
                createReindeer();

                animate();
            }

            function createGround() {
                const geo = new THREE.PlaneGeometry(120, 120, 80, 80);
                const pos = geo.attributes.position.array;
                for (let i = 2; i < pos.length; i += 3) pos[i] += Math.random() * 0.2 - 0.1;
                geo.computeVertexNormals();
                const mat = new THREE.MeshStandardMaterial({ color: 0xf8f8ff, roughness: 0.95 });
                const ground = new THREE.Mesh(geo, mat);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -3;
                ground.receiveShadow = true;
                scene.add(ground);
            }

            function createTree(x, z, scale = 1, isMain = false) {
                const group = new THREE.Group();
                group.position.set(x, -3, z);
                group.scale.set(scale, scale, scale);

                // Enhanced Trunk with Roots
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.9 });
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.6, 2.2, 8), trunkMat);
                trunk.position.y = 1.1; trunk.castShadow = true;
                group.add(trunk);

                // Visible Roots
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const root = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.15, 0.8, 6), trunkMat);
                    root.position.set(Math.cos(angle) * 0.4, 0.2, Math.sin(angle) * 0.4);
                    root.rotation.z = Math.cos(angle) * 0.5;
                    root.rotation.x = Math.sin(angle) * 0.5;
                    group.add(root);
                }

                // Foliage - Multiple Layered Tiers
                const foliageColors = [0x1d5a2e, 0x2d6a3e, 0x1a4d28]; // Color variation
                const tiers = [[2.5, 3.0, 3.0], [2.0, 2.8, 5.0], [1.6, 2.5, 7.0], [1.1, 2.0, 8.8], [0.6, 1.5, 10.2]];

                tiers.forEach(([radius, height, yPos], tierIndex) => {
                    const tierGroup = new THREE.Group();
                    tierGroup.position.y = yPos;

                    // Main Cone Shape
                    const coneMat = new THREE.MeshStandardMaterial({ color: foliageColors[tierIndex % foliageColors.length], roughness: 0.8 });
                    const mainCone = new THREE.Mesh(new THREE.ConeGeometry(radius, height, 12), coneMat);
                    mainCone.castShadow = true;
                    tierGroup.add(mainCone);

                    // Branch Clusters (small cones around the main shape for detail)
                    const numBranches = 8 + tierIndex * 2;
                    for (let i = 0; i < numBranches; i++) {
                        const angle = (i / numBranches) * Math.PI * 2 + Math.random() * 0.3;
                        const branchRadius = radius * (0.3 + Math.random() * 0.2);
                        const branchHeight = height * (0.4 + Math.random() * 0.2);
                        const branchY = -height * 0.3 + Math.random() * height * 0.4;

                        const branch = new THREE.Mesh(
                            new THREE.ConeGeometry(branchRadius, branchHeight, 6),
                            new THREE.MeshStandardMaterial({ color: foliageColors[(tierIndex + 1) % foliageColors.length], roughness: 0.85 })
                        );
                        branch.position.set(Math.cos(angle) * radius * 0.7, branchY, Math.sin(angle) * radius * 0.7);
                        branch.rotation.z = Math.cos(angle) * 0.3;
                        branch.rotation.x = Math.sin(angle) * 0.3;
                        branch.castShadow = true;
                        tierGroup.add(branch);
                    }

                    // Snow Accents on Top Tiers
                    if (tierIndex >= 2 && Math.random() > 0.3) {
                        const snowMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
                        const snowCap = new THREE.Mesh(new THREE.ConeGeometry(radius * 0.5, height * 0.2, 8), snowMat);
                        snowCap.position.y = height * 0.4;
                        tierGroup.add(snowCap);
                    }
                    group.add(tierGroup);
                });

                // String Lights wrapping the tree (for all trees, but more on main)
                const lightCount = isMain ? 80 : 30;
                const lightColors = [0xff0000, 0x00ff00, 0xffff00, 0x00ffff, 0xff00ff];
                for (let i = 0; i < lightCount; i++) {
                    const t = i / lightCount;
                    const h = 2.5 + t * 8.5;
                    const angle = i * (isMain ? 0.5 : 0.8);
                    // Calculate radius based on height to wrap around tiers
                    const r = 0.4 + (11 - h) * 0.22;

                    const light = new THREE.Mesh(
                        new THREE.SphereGeometry(0.06),
                        new THREE.MeshStandardMaterial({ color: lightColors[i % lightColors.length], emissive: lightColors[i % lightColors.length], emissiveIntensity: 0.8 })
                    );
                    light.position.set(Math.cos(angle) * r, h, Math.sin(angle) * r);
                    light.userData.isTreeLight = true;
                    light.userData.phase = Math.random() * Math.PI * 2;
                    group.add(light);
                }

                // Ornaments on all trees
                const ornCount = isMain ? 45 : 15;
                const ornColors = [0xff0000, 0x0066ff, 0xffd700, 0x00cc44, 0xff69b4, 0x9900ff];
                for (let i = 0; i < ornCount; i++) {
                    const h = 2.5 + Math.random() * 8;
                    const angle = Math.random() * Math.PI * 2;
                    const r = 0.5 + (11 - h) * 0.22;
                    const orn = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12),
                        new THREE.MeshStandardMaterial({ color: ornColors[Math.floor(Math.random() * ornColors.length)], metalness: 0.8, roughness: 0.2 }));
                    orn.position.set(Math.cos(angle) * r, h, Math.sin(angle) * r);
                    group.add(orn);
                }

                if (isMain) {
                    // Extra features for main tree
                    // Icicles hanging from branches
                    for (let i = 0; i < 15; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const h = 4 + Math.random() * 6;
                        const r = (11 - h) * 0.25;
                        const icicle = new THREE.Mesh(
                            new THREE.ConeGeometry(0.04, 0.3 + Math.random() * 0.3, 4),
                            new THREE.MeshStandardMaterial({ color: 0xaaddff, transparent: true, opacity: 0.7, metalness: 0.3 })
                        );
                        icicle.position.set(Math.cos(angle) * r, h - 0.5, Math.sin(angle) * r);
                        icicle.rotation.x = Math.PI; // Point downwards
                        group.add(icicle);
                    }
                }

                group.userData.phase = Math.random() * Math.PI * 2;
                scene.add(group);
                trees.push(group);
                return group;
            }

            function createForest() {
                christmasTree = createTree(-5, -3, 1.1, true);
                for (let i = 0; i < 20; i++) {
                    const x = (Math.random() - 0.5) * 60;
                    const z = -10 - Math.random() * 30;
                    if (Math.abs(x) < 8 && z > -15) continue;
                    createTree(x, z, 0.5 + Math.random());
                }
            }

            function createSnowman() {
                snowman = new THREE.Group();
                snowman.position.set(5, -3, 1);
                scene.add(snowman);
                const snowMat = new THREE.MeshStandardMaterial({ color: 0xfafafa, roughness: 0.85 });
                const coalMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });

                // Base, Middle, Head balls
                const balls = [[1.3, 1.3], [1.0, 3.2], [0.7, 4.6]];
                balls.forEach(([r, y], i) => {
                    const ball = new THREE.Mesh(new THREE.SphereGeometry(r, 28, 28), snowMat);
                    ball.position.y = y; ball.castShadow = true; snowman.add(ball);
                    if (i === 2) snowman.headBall = ball;
                });

                // Face Group (for easier animation)
                const faceGroup = new THREE.Group();
                faceGroup.position.y = 4.6;
                snowman.add(faceGroup);
                snowman.face = faceGroup;

                // Eyes with eyelids for blinking
                [-0.22, 0.22].forEach((x, idx) => {
                    const eyeGroup = new THREE.Group();
                    eyeGroup.position.set(x, 0.25, 0.58);

                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.08), coalMat);
                    eyeGroup.add(eye);

                    // Eyelid (same color as snow)
                    const eyelid = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), snowMat);
                    eyelid.rotation.x = Math.PI;
                    eyelid.position.y = 0.02;
                    eyelid.scale.y = 0;
                    eyeGroup.add(eyelid);

                    faceGroup.add(eyeGroup);
                    if (idx === 0) snowman.eyeL = eyelid; else snowman.eyeR = eyelid;
                });

                // Carrot Nose
                const nose = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.65, 8), new THREE.MeshStandardMaterial({ color: 0xff6b00 }));
                nose.rotation.x = Math.PI / 2; nose.position.set(0, -0.05, 0.75);
                faceGroup.add(nose);

                // Smile (coal pieces in arc)
                for (let i = 0; i < 5; i++) {
                    const angle = (i - 2) * 0.2;
                    const smileCoal = new THREE.Mesh(new THREE.SphereGeometry(0.04), coalMat);
                    smileCoal.position.set(Math.sin(angle) * 0.25, -0.25 - Math.cos(angle) * 0.08, 0.65);
                    faceGroup.add(smileCoal);
                }

                // Buttons
                for (let i = 0; i < 3; i++) {
                    const btn = new THREE.Mesh(new THREE.SphereGeometry(0.06), coalMat);
                    btn.position.set(0, 3.2 - i * 0.5, 1.25); // Adjusted for new coalMat
                    snowman.add(btn);
                }

                // Scarf
                const scarf = new THREE.Mesh(new THREE.TorusGeometry(0.85, 0.15, 8, 16), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                scarf.position.y = 4.3; scarf.rotation.x = Math.PI / 2;
                snowman.add(scarf);
                const scarfTail = new THREE.Mesh(new THREE.CapsuleGeometry(0.15, 1.2), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                scarfTail.position.set(0.6, 3.8, 0.5); scarfTail.rotation.z = -0.2;
                snowman.add(scarfTail);
                snowman.scarfTail = scarfTail;

                // Arm Branches
                const armMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });
                const armGeo = new THREE.CylinderGeometry(0.05, 0.05, 2.5);
                const armL = new THREE.Mesh(armGeo, armMat);
                armL.position.set(-1.2, 3.5, 0); armL.rotation.z = 1.2;
                snowman.add(armL); snowman.armL = armL;

                const armR = new THREE.Mesh(armGeo, armMat);
                armR.position.set(1.2, 3.5, 0); armR.rotation.z = -1.2;
                snowman.add(armR); snowman.armR = armR;
                // Top Hat
                const brim = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.12, 20), coalMat);
                brim.position.y = 5.3; snowman.add(brim);
                const topHat = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.45, 0.9, 20), coalMat);
                topHat.position.y = 5.8; snowman.add(topHat);

                // Holly on hat
                const hollyLeaf1 = new THREE.Mesh(new THREE.SphereGeometry(0.08), new THREE.MeshStandardMaterial({ color: 0x228b22 }));
                hollyLeaf1.position.set(0.3, 5.5, 0.35); hollyLeaf1.scale.set(1, 0.3, 0.7); snowman.add(hollyLeaf1);
                const hollyLeaf2 = hollyLeaf1.clone(); hollyLeaf2.position.set(0.4, 5.5, 0.25); snowman.add(hollyLeaf2);
                const hollyBerry = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshStandardMaterial({ color: 0xcc0000 }));
                hollyBerry.position.set(0.35, 5.5, 0.4); snowman.add(hollyBerry);
            }


            function createPresents() {
                const positions = [[-6.5, 0.5], [-5.2, 1.2], [-4, 0.8], [4, 2.5], [5.5, 2], [6.5, 1.8]];
                const colors = [0xd63031, 0x0984e3, 0x00b894, 0x6c5ce7, 0xfdcb6e, 0xe84393];
                positions.forEach((pos, i) => {
                    const size = 0.5 + Math.random() * 0.5;
                    const group = new THREE.Group();
                    group.position.set(pos[0], -3 + size / 2, pos[1]);
                    group.userData.baseY = group.position.y;
                    group.userData.phase = Math.random() * Math.PI * 2;

                    const boxMat = new THREE.MeshStandardMaterial({ color: colors[i % colors.length], roughness: 0.5, metalness: 0.1 });
                    const ribbonMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.7, roughness: 0.2 });

                    // Box Base (shorter to fit lid)
                    const boxBase = new THREE.Mesh(new THREE.BoxGeometry(size, size * 0.9, size), boxMat);
                    boxBase.castShadow = true;
                    group.add(boxBase);

                    // Ribbon on base
                    const ribV = new THREE.Mesh(new THREE.BoxGeometry(size * 0.12, size * 0.92, size + 0.02), ribbonMat);
                    group.add(ribV);
                    const ribH = new THREE.Mesh(new THREE.BoxGeometry(size + 0.02, size * 0.12, size + 0.02), ribbonMat);
                    group.add(ribH);

                    // Lid Group
                    const lidGroup = new THREE.Group();
                    lidGroup.position.y = size * 0.45;

                    const lid = new THREE.Mesh(new THREE.BoxGeometry(size * 1.05, size * 0.2, size * 1.05), boxMat);
                    lid.position.y = size * 0.1;
                    lidGroup.add(lid);

                    // Ribbon on lid
                    const ribLidV = new THREE.Mesh(new THREE.BoxGeometry(size * 0.14, size * 0.22, size * 1.07), ribbonMat);
                    ribLidV.position.y = size * 0.1;
                    lidGroup.add(ribLidV);
                    const ribLidH = new THREE.Mesh(new THREE.BoxGeometry(size * 1.07, size * 0.22, size * 0.14), ribbonMat);
                    ribLidH.position.y = size * 0.1;
                    lidGroup.add(ribLidH);

                    const bow = new THREE.Mesh(new THREE.TorusGeometry(size * 0.15, size * 0.05, 8, 12), ribbonMat);
                    bow.position.y = size * 0.22;
                    bow.rotation.x = Math.PI / 2;
                    lidGroup.add(bow);

                    group.add(lidGroup);
                    group.lid = lidGroup;
                    group.lidBaseY = lidGroup.position.y;

                    // Light inside for "opening" effect
                    const interiorLight = new THREE.PointLight(0xffffaa, 0, 3);
                    interiorLight.position.y = 0.2;
                    group.add(interiorLight);
                    group.light = interiorLight;

                    presents.push(group);
                    scene.add(group);
                });
            }

            function createElf() {
                elf = new THREE.Group();
                elf.position.set(2.8, -3, 4); elf.rotation.y = -0.35;
                scene.add(elf);
                const skin = new THREE.MeshStandardMaterial({ color: 0xffe4cc, roughness: 0.65 });
                const suit = new THREE.MeshStandardMaterial({ color: 0x2ecc71, roughness: 0.55 });
                const red = new THREE.MeshStandardMaterial({ color: 0xe74c3c, roughness: 0.55 });
                const white = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.75 });
                const belt = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
                const gold = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.1 });

                // Create legs WITH boots and candy cane stripes
                const createLeg = (x) => {
                    const lg = new THREE.Group();
                    lg.position.set(x, 1.1, 0);

                    // Leg mesh (green pants with red stripe)
                    const mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.13, 0.16, 1.1), suit);
                    mesh.position.y = -0.55;
                    mesh.castShadow = true;
                    lg.add(mesh);

                    // Red stripe on pants
                    const stripe = new THREE.Mesh(new THREE.CylinderGeometry(0.14, 0.17, 0.12), red);
                    stripe.position.y = -0.3;
                    lg.add(stripe);

                    // Curly elf boot
                    const bootBase = new THREE.Mesh(new THREE.CapsuleGeometry(0.16, 0.3, 8, 10), suit);
                    bootBase.position.y = -0.85;
                    bootBase.castShadow = true;
                    lg.add(bootBase);

                    // Curly toe
                    const toe = new THREE.Mesh(new THREE.SphereGeometry(0.1), suit);
                    toe.position.set(0, -0.95, 0.18);
                    lg.add(toe);

                    // Jingle bell on toe
                    const bell = new THREE.Mesh(new THREE.SphereGeometry(0.06), gold);
                    bell.position.set(0, -0.95, 0.28);
                    lg.add(bell);
                    lg.bell = bell;

                    return lg;
                };
                elf.legL = createLeg(-0.28); elf.legR = createLeg(0.28);
                elf.add(elf.legL); elf.add(elf.legR);

                // UPPER BODY GROUP (For waist bending)
                const upperBody = new THREE.Group();
                upperBody.position.y = 1.1; // Lowered to align with legs (waist pivot)
                elf.add(upperBody);
                elf.upperBody = upperBody;

                // Torso with festive details
                const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.45, 1.15), suit);
                torso.position.y = 0.55; torso.castShadow = true; upperBody.add(torso);

                // Decorative buttons
                [0.3, 0.55, 0.8].forEach(y => {
                    const button = new THREE.Mesh(new THREE.SphereGeometry(0.06), gold);
                    button.position.set(0, y, 0.4);
                    upperBody.add(button);
                });

                const beltMesh = new THREE.Mesh(new THREE.TorusGeometry(0.42, 0.08, 10, 20), belt);
                beltMesh.position.y = 0.1; beltMesh.rotation.x = Math.PI / 2; upperBody.add(beltMesh);
                const buckle = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.18, 0.06), gold);
                buckle.position.set(0, 0.1, 0.44); upperBody.add(buckle);

                // Fluffy collar
                const collar = new THREE.Mesh(new THREE.TorusGeometry(0.38, 0.12, 10, 20), white);
                collar.position.y = 1.05; collar.rotation.x = Math.PI / 2; upperBody.add(collar);

                // Head with cuter proportions
                const headJoint = new THREE.Group(); headJoint.position.y = 1.3;
                upperBody.add(headJoint); elf.headJoint = headJoint;
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.5), skin); // Bigger head = cuter
                head.position.y = 0.28; head.castShadow = true; headJoint.add(head);

                // Pointy Elf Ears
                [-0.48, 0.48].forEach(x => {
                    const ear = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.35, 8), skin);
                    ear.position.set(x, 0.3, 0);
                    ear.rotation.z = x > 0 ? 0.7 : -0.7;
                    ear.rotation.y = x > 0 ? 0.3 : -0.3;
                    headJoint.add(ear);
                    // Ear tip pink
                    const earTip = new THREE.Mesh(new THREE.SphereGeometry(0.04), new THREE.MeshStandardMaterial({ color: 0xffb6c1 }));
                    earTip.position.set(x * 1.15, 0.42, 0);
                    headJoint.add(earTip);
                });

                // Cute friendly eyes (natural style, not scary)
                [-0.14, 0.14].forEach(x => {
                    // Eye white (normal size)
                    const eyeW = new THREE.Mesh(new THREE.SphereGeometry(0.09), white);
                    eyeW.position.set(x, 0.32, 0.42);
                    headJoint.add(eyeW);

                    // Black pupil (friendly size)
                    const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshBasicMaterial({ color: 0x2c1810 }));
                    pupil.position.set(x, 0.32, 0.49);
                    headJoint.add(pupil);

                    // Small sparkle highlight
                    const sparkle = new THREE.Mesh(new THREE.SphereGeometry(0.018), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    sparkle.position.set(x + 0.02, 0.34, 0.52);
                    headJoint.add(sparkle);
                });

                // Proper visible eyebrows
                [-0.14, 0.14].forEach(x => {
                    // Main eyebrow shape (thicker and longer)
                    const brow = new THREE.Mesh(
                        new THREE.CapsuleGeometry(0.025, 0.1, 6, 8),
                        new THREE.MeshStandardMaterial({ color: 0x5d3a1a, roughness: 0.8 })
                    );
                    brow.position.set(x, 0.46, 0.4);
                    brow.rotation.z = x > 0 ? 0.25 : -0.25; // Slight friendly arch
                    brow.rotation.x = 0.3; // Tilt forward to be visible
                    headJoint.add(brow);
                });

                // Rosy cheeks
                [-0.22, 0.22].forEach(x => {
                    const cheek = new THREE.Mesh(new THREE.SphereGeometry(0.07), new THREE.MeshStandardMaterial({ color: 0xffb6c1, transparent: true, opacity: 0.5 }));
                    cheek.position.set(x, 0.2, 0.42);
                    headJoint.add(cheek);
                });

                // Small nose
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.06), skin);
                nose.position.set(0, 0.28, 0.52);
                headJoint.add(nose);

                // Mouth (happy smile)
                const mouth = new THREE.Mesh(new THREE.TorusGeometry(0.1, 0.025, 8, 12, Math.PI), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                mouth.position.set(0, 0.12, 0.48);
                mouth.rotation.x = Math.PI / 1.1;
                headJoint.add(mouth);
                elf.mouth = mouth;

                // Elf Hat with stripes
                const hatBase = new THREE.Mesh(new THREE.CylinderGeometry(0.52, 0.52, 0.16, 18), white);
                hatBase.position.y = 0.78; headJoint.add(hatBase);

                // Striped cone hat
                const hatCone = new THREE.Mesh(new THREE.ConeGeometry(0.42, 1.1, 12), red);
                hatCone.position.y = 1.3; hatCone.rotation.x = 0.2; headJoint.add(hatCone);
                // Green stripe on hat
                const hatStripe = new THREE.Mesh(new THREE.TorusGeometry(0.3, 0.06, 8, 16), suit);
                hatStripe.position.y = 1.0; hatStripe.rotation.x = Math.PI / 2.2; headJoint.add(hatStripe);

                const pomPom = new THREE.Mesh(new THREE.SphereGeometry(0.16), white);
                pomPom.position.set(0.15, 1.8, 0.25); headJoint.add(pomPom);
                // Jingle bell on hat
                const hatBell = new THREE.Mesh(new THREE.SphereGeometry(0.08), gold);
                hatBell.position.set(0.15, 1.65, 0.3); headJoint.add(hatBell);

                // Arms with proper pivot
                const createArm = (x) => {
                    const ag = new THREE.Group();
                    ag.position.set(x, 0.85, 0);

                    // Upper arm (green sleeve)
                    const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.55), suit);
                    upper.position.y = -0.25;
                    upper.castShadow = true;
                    ag.add(upper);

                    // Cuff
                    const cuff = new THREE.Mesh(new THREE.CylinderGeometry(0.13, 0.13, 0.08), white);
                    cuff.position.y = -0.5;
                    ag.add(cuff);

                    // Hand
                    const hand = new THREE.Mesh(new THREE.SphereGeometry(0.12), skin);
                    hand.position.y = -0.6;
                    ag.add(hand);
                    return ag;
                };
                elf.armL = createArm(-0.52); elf.armR = createArm(0.52);
                upperBody.add(elf.armL); upperBody.add(elf.armR);
            }

            function createSparkles() {
                props.sparkles = new THREE.Group();
                for (let i = 0; i < 40; i++) {
                    const s = new THREE.Mesh(new THREE.OctahedronGeometry(0.05), new THREE.MeshBasicMaterial({ color: 0xffffaa }));
                    s.position.set((Math.random() - 0.5) * 30, Math.random() * 15, (Math.random() - 0.5) * 25 - 5);
                    s.userData.speed = 1 + Math.random() * 2; s.userData.phase = Math.random() * Math.PI * 2;
                    props.sparkles.add(s);
                }
                scene.add(props.sparkles);
            }

            function createSnow() {
                props.snow = new THREE.Group();
                const geo = new THREE.BufferGeometry();
                const count = 4000; // Increased count
                const pos = new Float32Array(count * 3);
                for (let i = 0; i < count * 3; i += 3) {
                    pos[i] = (Math.random() - 0.5) * 60; pos[i + 1] = Math.random() * 35; pos[i + 2] = (Math.random() - 0.5) * 60;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                props.snow.add(new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.8 })));
                scene.add(props.snow);
            }

            function createStars() {
                props.stars = new THREE.Group();
                for (let i = 0; i < 80; i++) {
                    const star = new THREE.Mesh(new THREE.OctahedronGeometry(0.08 + Math.random() * 0.15), new THREE.MeshBasicMaterial({ color: 0xffffcc }));
                    star.position.set((Math.random() - 0.5) * 50, 12 + Math.random() * 25, (Math.random() - 0.5) * 40 - 15);
                    star.userData.twinkleSpeed = 2 + Math.random() * 3; star.userData.phase = Math.random() * Math.PI * 2;
                    props.stars.add(star);
                }
                scene.add(props.stars);
                props.stars.visible = false;
            }

            function createAurora() {
                props.aurora = new THREE.Group();
                const geo = new THREE.PlaneGeometry(80, 20, 20, 5);
                const mat = new THREE.MeshBasicMaterial({ color: 0x22ff88, transparent: true, opacity: 0.3, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
                const mesh = new THREE.Mesh(geo, mat); mesh.position.set(0, 15, -20); mesh.rotation.x = -0.5;
                props.aurora.add(mesh); scene.add(props.aurora); props.aurora.visible = false;
            }

            function createSleigh() {
                props.sleigh = new THREE.Group();
                props.sleigh.position.set(-25, 20, -15);
                props.sleigh.add(new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.6, 1.2), new THREE.MeshStandardMaterial({ color: 0xcc0000 })));
                props.sleighTrail = new THREE.Group(); scene.add(props.sleighTrail); scene.add(props.sleigh);
            }

            function createCandyCanes() {
                props.candyCanes = new THREE.Group();
                [[-8, 0], [-7, 2], [7, 1], [8, -1]].forEach(([x, z]) => {
                    const cane = new THREE.Group(); cane.position.set(x, -3, z);
                    const st = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 2), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                    st.position.y = 1; cane.add(st);
                    const crv = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.1, 8, 12, Math.PI), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                    crv.position.set(0.35, 2, 0); crv.rotation.z = Math.PI / 2; cane.add(crv);
                    for (let i = 0; i < 8; i++) {
                        const str = new THREE.Mesh(new THREE.TorusGeometry(0.12, 0.03, 6, 12), new THREE.MeshStandardMaterial({ color: 0xcc0000 }));
                        str.position.y = 0.3 + i * 0.25; str.rotation.x = Math.PI / 2; cane.add(str);
                    }
                    cane.userData.phase = Math.random() * Math.PI * 2; props.candyCanes.add(cane);
                });
                scene.add(props.candyCanes);
            }

            // ============ NEW LIFE ELEMENTS ============

            // Floating Paper Lanterns
            function createSnow() {
                const particleCount = 2000;
                const geom = new THREE.BufferGeometry();
                const pos = [];
                for (let i = 0; i < particleCount; i++) {
                    pos.push((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 40, (Math.random() - 0.5) * 80);
                }
                geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true });
                props.snow = new THREE.Points(geom, mat);
                scene.add(props.snow);
            }

            function createFloatingLanterns() {
                props.lanterns = new THREE.Group();
                const lanternColors = [0xff6600, 0xffaa00, 0xff4444, 0xffcc00];
                for (let i = 0; i < 12; i++) {
                    const lantern = new THREE.Group();
                    const x = (Math.random() - 0.5) * 50;
                    const y = 8 + Math.random() * 12;
                    const z = (Math.random() - 0.5) * 40 - 10;
                    lantern.position.set(x, y, z);

                    // Lantern Body
                    const color = lanternColors[Math.floor(Math.random() * lanternColors.length)];
                    const body = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.4, 0.8, 8),
                        new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5, transparent: true, opacity: 0.85 })
                    );
                    lantern.add(body);

                    // Inner Glow
                    const glow = new THREE.Mesh(
                        new THREE.SphereGeometry(0.25),
                        new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0.6 })
                    );
                    lantern.add(glow);

                    // Top Cap
                    const cap = new THREE.Mesh(
                        new THREE.ConeGeometry(0.2, 0.2, 6),
                        new THREE.MeshStandardMaterial({ color: 0x4a3728 })
                    );
                    cap.position.y = 0.5;
                    lantern.add(cap);

                    lantern.userData.speed = 0.2 + Math.random() * 0.3;
                    lantern.userData.phase = Math.random() * Math.PI * 2;
                    lantern.userData.driftX = (Math.random() - 0.5) * 0.01;
                    props.lanterns.add(lantern);
                }
                scene.add(props.lanterns);
            }

            // Proper Cute Rabbits with Hopping Animation
            function createBunnies() {
                props.bunnies = new THREE.Group();
                const bunnyColors = [0xffffff, 0xf5f5dc, 0xd2b48c, 0xe8e0d5]; // White, cream, tan, light grey
                const pinkMat = new THREE.MeshStandardMaterial({ color: 0xffb6c1, roughness: 0.6 });
                const blackMat = new THREE.MeshBasicMaterial({ color: 0x111111 });

                for (let i = 0; i < 8; i++) {
                    const bunny = new THREE.Group();
                    const x = (Math.random() - 0.5) * 40;
                    const z = (Math.random() - 0.5) * 30;
                    bunny.position.set(x, -2.85, z);
                    bunny.scale.set(0.35, 0.35, 0.35);

                    const furColor = bunnyColors[Math.floor(Math.random() * bunnyColors.length)];
                    const bunnyMat = new THREE.MeshStandardMaterial({ color: furColor, roughness: 0.85 });

                    // Body (elongated oval)
                    const body = new THREE.Mesh(new THREE.SphereGeometry(0.55, 16, 12), bunnyMat);
                    body.scale.set(0.9, 0.75, 1.3);
                    bunny.add(body);
                    bunny.body = body;

                    // Head (rounder)
                    const head = new THREE.Mesh(new THREE.SphereGeometry(0.38, 16, 12), bunnyMat);
                    head.position.set(0, 0.35, 0.55);
                    bunny.add(head);
                    bunny.head = head;

                    // Cheeks (puffy)
                    [-0.18, 0.18].forEach(cx => {
                        const cheek = new THREE.Mesh(new THREE.SphereGeometry(0.12), bunnyMat);
                        cheek.position.set(cx, 0.25, 0.8);
                        bunny.add(cheek);
                    });

                    // Ears (tall and floppy)
                    [-0.12, 0.12].forEach((ex, idx) => {
                        const earGroup = new THREE.Group();
                        earGroup.position.set(ex, 0.7, 0.45);

                        // Outer ear
                        const ear = new THREE.Mesh(new THREE.CapsuleGeometry(0.09, 0.55, 6, 10), bunnyMat);
                        ear.rotation.x = -0.25;
                        ear.rotation.z = ex > 0 ? 0.15 : -0.15; // Slight outward tilt
                        earGroup.add(ear);

                        // Inner ear (pink)
                        const innerEar = new THREE.Mesh(new THREE.CapsuleGeometry(0.05, 0.4, 6, 8), pinkMat);
                        innerEar.position.z = 0.03;
                        innerEar.rotation.x = -0.25;
                        innerEar.rotation.z = ex > 0 ? 0.15 : -0.15;
                        earGroup.add(innerEar);

                        bunny.add(earGroup);
                        if (idx === 0) bunny.earL = earGroup; else bunny.earR = earGroup;
                    });

                    // Eyes (big and sparkly)
                    [-0.11, 0.11].forEach(ex => {
                        const eyeWhite = new THREE.Mesh(new THREE.SphereGeometry(0.08), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                        eyeWhite.position.set(ex, 0.42, 0.85);
                        bunny.add(eyeWhite);
                        const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.045), blackMat);
                        pupil.position.set(ex, 0.42, 0.92);
                        bunny.add(pupil);
                        // Eye sparkle
                        const sparkle = new THREE.Mesh(new THREE.SphereGeometry(0.015), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                        sparkle.position.set(ex + 0.02, 0.44, 0.94);
                        bunny.add(sparkle);
                    });

                    // Nose (twitchy pink)
                    const nose = new THREE.Mesh(new THREE.SphereGeometry(0.06), pinkMat);
                    nose.position.set(0, 0.3, 0.92);
                    nose.scale.set(1, 0.7, 0.8);
                    bunny.add(nose);
                    bunny.nose = nose;

                    // Whiskers (thin lines)
                    [-1, 1].forEach(side => {
                        for (let w = 0; w < 3; w++) {
                            const whisker = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.005, 0.005, 0.25, 4),
                                new THREE.MeshBasicMaterial({ color: 0x888888 })
                            );
                            whisker.position.set(side * 0.15, 0.28 + (w - 1) * 0.04, 0.88);
                            whisker.rotation.z = side * (1.4 + w * 0.1);
                            whisker.rotation.x = 0.2;
                            bunny.add(whisker);
                        }
                    });

                    // Front Legs (small paws)
                    [-0.18, 0.18].forEach((lx, idx) => {
                        const legGroup = new THREE.Group();
                        legGroup.position.set(lx, -0.3, 0.35);
                        const leg = new THREE.Mesh(new THREE.CapsuleGeometry(0.07, 0.2, 4, 6), bunnyMat);
                        legGroup.add(leg);
                        bunny.add(legGroup);
                        if (idx === 0) bunny.frontLegL = legGroup; else bunny.frontLegR = legGroup;
                    });

                    // Back Legs (bigger, powerful)
                    [-0.22, 0.22].forEach((lx, idx) => {
                        const legGroup = new THREE.Group();
                        legGroup.position.set(lx, -0.25, -0.35);
                        const thigh = new THREE.Mesh(new THREE.SphereGeometry(0.15), bunnyMat);
                        thigh.scale.set(0.8, 1.2, 1);
                        legGroup.add(thigh);
                        const foot = new THREE.Mesh(new THREE.CapsuleGeometry(0.06, 0.2, 4, 6), bunnyMat);
                        foot.position.y = -0.2;
                        foot.rotation.x = 0.5;
                        legGroup.add(foot);
                        bunny.add(legGroup);
                        if (idx === 0) bunny.backLegL = legGroup; else bunny.backLegR = legGroup;
                    });

                    // Fluffy Tail
                    const tail = new THREE.Mesh(new THREE.SphereGeometry(0.18), bunnyMat);
                    tail.position.set(0, 0.05, -0.7);
                    bunny.add(tail);
                    bunny.tail = tail;

                    bunny.userData.hopPhase = Math.random() * Math.PI * 2;
                    bunny.userData.hopSpeed = 1.2 + Math.random() * 0.8;
                    bunny.userData.direction = Math.random() * Math.PI * 2;
                    bunny.userData.idleTime = 0;
                    bunny.userData.isResting = Math.random() > 0.5;
                    props.bunnies.add(bunny);
                }
                scene.add(props.bunnies);
            }

            // Fireflies / Magic Particles
            function createFireflies() {
                props.fireflies = new THREE.Group();
                for (let i = 0; i < 50; i++) {
                    const firefly = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05 + Math.random() * 0.05),
                        new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0.8 })
                    );
                    firefly.position.set(
                        (Math.random() - 0.5) * 50,
                        1 + Math.random() * 10,
                        (Math.random() - 0.5) * 40
                    );
                    firefly.userData.speed = 0.5 + Math.random();
                    firefly.userData.phase = Math.random() * Math.PI * 2;
                    firefly.userData.orbitRadius = 0.5 + Math.random() * 2;
                    props.fireflies.add(firefly);
                }
                scene.add(props.fireflies);
            }

            // Flying Owls
            function createFlyingOwls() {
                props.owls = new THREE.Group();
                const owlColors = [0x8B7355, 0x6B5344, 0x5D4037];

                for (let i = 0; i < 4; i++) {
                    const owl = new THREE.Group();
                    const color = owlColors[Math.floor(Math.random() * owlColors.length)];
                    const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });
                    const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

                    // Body
                    const body = new THREE.Mesh(new THREE.SphereGeometry(0.4, 12, 12), mat);
                    body.scale.set(0.8, 1, 0.7);
                    owl.add(body);

                    // Head
                    const head = new THREE.Mesh(new THREE.SphereGeometry(0.3), mat);
                    head.position.y = 0.5;
                    owl.add(head);

                    // Eyes (big owl eyes)
                    [-0.12, 0.12].forEach(ex => {
                        const eyeWhite = new THREE.Mesh(new THREE.SphereGeometry(0.12), whiteMat);
                        eyeWhite.position.set(ex, 0.55, 0.22);
                        owl.add(eyeWhite);

                        const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                        pupil.position.set(ex, 0.55, 0.32);
                        owl.add(pupil);
                    });

                    // Beak
                    const beak = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.12, 4), new THREE.MeshStandardMaterial({ color: 0xffaa00 }));
                    beak.position.set(0, 0.45, 0.28);
                    beak.rotation.x = Math.PI / 2;
                    owl.add(beak);

                    // Wings
                    [-0.4, 0.4].forEach((wx, idx) => {
                        const wing = new THREE.Mesh(new THREE.SphereGeometry(0.25), mat);
                        wing.scale.set(0.3, 0.8, 0.5);
                        wing.position.set(wx, 0.1, 0);
                        owl.add(wing);
                        if (idx === 0) owl.wingL = wing;
                        else owl.wingR = wing;
                    });

                    owl.position.set(
                        (Math.random() - 0.5) * 80, // Start anywhere
                        10 + Math.random() * 8,
                        (Math.random() - 0.5) * 15 - 10 // Stay in the back
                    );
                    owl.scale.set(0.6, 0.6, 0.6);
                    owl.userData.speed = 0.08 + Math.random() * 0.12;
                    owl.userData.direction = Math.random() > 0.5 ? 1 : -1;
                    owl.userData.baseY = owl.position.y;
                    props.owls.add(owl);
                }
                scene.add(props.owls);
            }

            // Ground Decorations (Mushrooms, Rocks, etc.)
            function createGroundDecor() {
                props.groundDecor = new THREE.Group();

                // Mushrooms
                const mushroomColors = [0xff4444, 0xffaa00, 0x8844ff];
                for (let i = 0; i < 15; i++) {
                    const mushroom = new THREE.Group();
                    const x = (Math.random() - 0.5) * 40;
                    const z = (Math.random() - 0.5) * 30;
                    mushroom.position.set(x, -2.9, z);
                    mushroom.scale.set(0.3 + Math.random() * 0.3, 0.3 + Math.random() * 0.3, 0.3 + Math.random() * 0.3);

                    // Stem
                    const stem = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.2, 0.5, 8),
                        new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.8 })
                    );
                    stem.position.y = 0.25;
                    mushroom.add(stem);

                    // Cap
                    const color = mushroomColors[Math.floor(Math.random() * mushroomColors.length)];
                    const cap = new THREE.Mesh(
                        new THREE.SphereGeometry(0.4, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                        new THREE.MeshStandardMaterial({ color: color, roughness: 0.6 })
                    );
                    cap.position.y = 0.5;
                    mushroom.add(cap);

                    // Spots
                    for (let j = 0; j < 5; j++) {
                        const spot = new THREE.Mesh(
                            new THREE.CircleGeometry(0.06, 8),
                            new THREE.MeshBasicMaterial({ color: 0xffffff })
                        );
                        const angle = Math.random() * Math.PI * 2;
                        const tilt = Math.random() * 0.5;
                        spot.position.set(Math.cos(angle) * 0.3, 0.55 + tilt * 0.1, Math.sin(angle) * 0.3);
                        spot.lookAt(mushroom.position.x, mushroom.position.y + 2, mushroom.position.z);
                        mushroom.add(spot);
                    }
                    props.groundDecor.add(mushroom);
                }

                // Snow-covered rocks
                for (let i = 0; i < 10; i++) {
                    const rock = new THREE.Group();
                    const x = (Math.random() - 0.5) * 45;
                    const z = (Math.random() - 0.5) * 35;
                    rock.position.set(x, -2.85, z);

                    const rockMesh = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(0.3 + Math.random() * 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.9 })
                    );
                    rockMesh.scale.set(1, 0.6, 1);
                    rock.add(rockMesh);

                    // Snow on top
                    const snow = new THREE.Mesh(
                        new THREE.SphereGeometry(0.25, 8, 4, 0, Math.PI * 2, 0, Math.PI / 3),
                        new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 })
                    );
                    snow.position.y = 0.15;
                    rock.add(snow);

                    props.groundDecor.add(rock);
                }
                scene.add(props.groundDecor);
            }


            // ============ SCENE CHARACTERS ============

            // Scene 1: Cute Puppy
            function createPuppy() {
                props.puppy = new THREE.Group();
                props.puppy.position.set(-0.8, -2.8, 1.2);
                const brown = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
                const darkBrown = new THREE.MeshStandardMaterial({ color: 0x5D3A1A, roughness: 0.7 });

                // Shadow Blob (to prevent "floating")
                const shadowGeo = new THREE.CircleGeometry(0.4, 16);
                const shadowMat = new THREE.MeshBasicMaterial({ color: 0x222222, transparent: true, opacity: 0.3 });
                const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                shadow.rotation.x = -Math.PI / 2;
                shadow.position.y = -0.19;
                props.puppy.add(shadow);

                // Body
                const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.3, 0.5, 8, 12), brown);
                body.rotation.z = Math.PI / 2; body.position.y = 0.3;
                body.castShadow = true; props.puppy.add(body);

                // Head
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.28), brown);
                head.position.set(0.45, 0.4, 0); head.castShadow = true;
                props.puppy.add(head); props.puppy.head = head;

                // ... (remaining parts with castShadow)
                const snout = new THREE.Mesh(new THREE.SphereGeometry(0.12), darkBrown);
                snout.position.set(0.65, 0.35, 0); props.puppy.add(snout);
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                nose.position.set(0.75, 0.38, 0); props.puppy.add(nose);
                [-0.08, 0.08].forEach(z => {
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                    eye.position.set(0.6, 0.5, z); props.puppy.add(eye);
                });
                [-0.2, 0.2].forEach(z => {
                    const ear = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8, 0, Math.PI), darkBrown);
                    ear.position.set(0.4, 0.6, z); ear.rotation.x = z > 0 ? 0.5 : -0.5; props.puppy.add(ear);
                });
                const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.06, 0.3), brown);
                tail.position.set(-0.4, 0.4, 0); tail.rotation.z = -0.5;
                props.puppy.add(tail); props.puppy.tail = tail;

                [[-0.15, -0.1], [-0.15, 0.1], [0.2, -0.1], [0.2, 0.1]].forEach(([x, z]) => {
                    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.25), brown);
                    leg.position.set(x, 0.1, z); leg.castShadow = true;
                    props.puppy.add(leg);
                });

                props.puppy.visible = false;
                scene.add(props.puppy);
            }

            // Scene 2: Santa Claus (in sleigh)
            function createSanta() {
                props.santa = new THREE.Group();
                // Santa sits in the sleigh (local coordinates)
                props.santa.position.set(0, 0, 0);
                props.santa.rotation.y = -Math.PI / 2; // Face forward (+X direction of sleigh movement)
                const red = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
                const white = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const skin = new THREE.MeshStandardMaterial({ color: 0xffccaa });

                // Legs for grounding
                const createLeg = (x) => {
                    const lg = new THREE.Group();
                    lg.position.set(x, 0.9, 0);
                    const boot = new THREE.Mesh(new THREE.CapsuleGeometry(0.18, 0.35, 8, 10), new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
                    boot.position.y = -0.85; lg.add(boot);
                    const mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.18, 0.9), red);
                    mesh.position.y = -0.45; lg.add(mesh);
                    return lg;
                };
                const legL = createLeg(-0.25); const legR = createLeg(0.25);
                props.santa.add(legL); props.santa.add(legR);
                props.santa.legL = legL; props.santa.legR = legR;

                // Body (raised to sit on legs)
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 1.2, 12), red);
                body.position.y = 1.5; // Raised from 0.6
                props.santa.add(body);

                // Belt
                const belt = new THREE.Mesh(new THREE.TorusGeometry(0.55, 0.08, 8, 16), new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
                belt.position.y = 1.3; // Raised from 0.4
                belt.rotation.x = Math.PI / 2;
                props.santa.add(belt);

                // Head
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.35), skin);
                head.position.y = 2.4; // Raised from 1.5
                props.santa.add(head);
                props.santa.head = head;

                // Beard
                const beard = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.5, 8), white);
                beard.position.set(0, 2.1, 0.2); // Raised from 1.2
                beard.rotation.x = 0.3;
                props.santa.add(beard);

                // Hat
                const hatBase = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.38, 0.1, 12), white);
                hatBase.position.y = 2.7; // Raised from 1.8
                props.santa.add(hatBase);
                const hatCone = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.6, 12), red);
                hatCone.position.y = 3.05; // Raised from 2.15
                props.santa.add(hatCone);
                const pomPom = new THREE.Mesh(new THREE.SphereGeometry(0.1), white);
                pomPom.position.set(0.15, 3.3, 0.1); // Raised from 2.4
                props.santa.add(pomPom);

                // ===== SANTA'S FACE =====
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
                const cheekMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, roughness: 0.8 });

                // Eyes (twinkling)
                [-0.12, 0.12].forEach(x => {
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.05), eyeMat);
                    eye.position.set(x, 2.45, 0.3); // Raised 0.9
                    props.santa.add(eye);
                    // Eye highlights
                    const highlight = new THREE.Mesh(new THREE.SphereGeometry(0.015), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    highlight.position.set(x + 0.02, 2.47, 0.34); // Raised 0.9
                    props.santa.add(highlight);
                });

                // Eyebrows (bushy white)
                [-0.12, 0.12].forEach(x => {
                    const brow = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.03, 0.03), white);
                    brow.position.set(x, 2.55, 0.28); // Raised 0.9
                    brow.rotation.z = x > 0 ? -0.2 : 0.2;
                    props.santa.add(brow);
                });

                // Rosy Cheeks
                [-0.2, 0.2].forEach(x => {
                    const cheek = new THREE.Mesh(new THREE.SphereGeometry(0.06), cheekMat);
                    cheek.position.set(x, 2.35, 0.25); // Raised 0.9
                    props.santa.add(cheek);
                });

                // Nose (round and red)
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.07), new THREE.MeshStandardMaterial({ color: 0xffaaaa }));
                nose.position.set(0, 2.38, 0.35); // Raised 0.9
                props.santa.add(nose);

                // Jolly Smile (curved black mouth like Elf)
                const mouth = new THREE.Mesh(new THREE.TorusGeometry(0.1, 0.02, 8, 16, Math.PI), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                mouth.position.set(0, 2.25, 0.32);
                mouth.rotation.x = Math.PI / 1.1;
                props.santa.add(mouth);
                props.santa.mouth = mouth;

                // Arms with Shoulder Pivot and Hands
                [-0.6, 0.6].forEach(x => {
                    const armGroup = new THREE.Group();
                    armGroup.position.set(x, 1.85, 0); // Shoulder position

                    const arm = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 0.45), red);
                    arm.position.y = -0.22; // Offset geometry down so pivot is at top
                    arm.castShadow = true;
                    armGroup.add(arm);

                    // Hands (Skin colored spheres)
                    const hand = new THREE.Mesh(new THREE.SphereGeometry(0.12), skin);
                    hand.position.y = -0.5;
                    armGroup.add(hand);

                    // Resting pose: Down and slightly out
                    armGroup.rotation.z = x > 0 ? -0.3 : 0.3;

                    props.santa.add(armGroup);
                    if (x > 0) props.santa.armR = armGroup; else props.santa.armL = armGroup;
                });

                props.santa.visible = false;
                if (props.sleigh) {
                    props.sleigh.add(props.santa);
                } else {
                    scene.add(props.santa);
                }
            }

            // Scene 3: Gingerbread Man
            function createGingerbread() {
                props.gingerbread = new THREE.Group();
                props.gingerbread.position.set(-5, -2.5, 2);
                const ginger = new THREE.MeshStandardMaterial({ color: 0xCD853F, roughness: 0.8 });
                const icing = new THREE.MeshStandardMaterial({ color: 0xffffff });

                // Body
                const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.25, 0.4, 8, 12), ginger);
                body.position.y = 0.5;
                props.gingerbread.add(body);

                // Head
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.22), ginger);
                head.position.y = 1.0;
                props.gingerbread.add(head);
                props.gingerbread.head = head;

                // Eyes (icing)
                [-0.08, 0.08].forEach(x => {
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04), icing);
                    eye.position.set(x, 1.05, 0.2);
                    props.gingerbread.add(eye);
                });

                // Smile
                const smile = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.02, 8, 12, Math.PI), icing);
                smile.position.set(0, 0.92, 0.2);
                smile.rotation.x = Math.PI;
                props.gingerbread.add(smile);

                // Buttons
                [0.6, 0.45, 0.3].forEach(y => {
                    const btn = new THREE.Mesh(new THREE.SphereGeometry(0.04), icing);
                    btn.position.set(0, y, 0.25);
                    props.gingerbread.add(btn);
                });

                // Arms
                const armL = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.25), ginger);
                armL.position.set(-0.35, 0.6, 0);
                armL.rotation.z = 0.8;
                props.gingerbread.add(armL);
                props.gingerbread.armL = armL;

                const armR = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.25), ginger);
                armR.position.set(0.35, 0.6, 0);
                armR.rotation.z = -0.8;
                props.gingerbread.add(armR);
                props.gingerbread.armR = armR;

                // Legs
                [-0.12, 0.12].forEach(x => {
                    const leg = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.2), ginger);
                    leg.position.set(x, 0.1, 0);
                    props.gingerbread.add(leg);
                });

                props.gingerbread.visible = false;
                scene.add(props.gingerbread);
            }

            // Scene 4: Family Group (3 figures)
            function createFamily() {
                props.family = new THREE.Group();
                props.family.position.set(3, -3, 5);

                const createPerson = (height, color, x, isMe) => {
                    const person = new THREE.Group();
                    person.position.x = x;
                    const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6 });
                    const skin = new THREE.MeshStandardMaterial({ color: 0xffccaa });
                    const black = new THREE.MeshBasicMaterial({ color: 0x000000 });

                    // Body
                    const body = new THREE.Mesh(new THREE.CylinderGeometry(height * 0.18, height * 0.22, height * 0.55), mat);
                    body.position.y = height * 0.28;
                    body.castShadow = true;
                    person.add(body);

                    // Head
                    const head = new THREE.Mesh(new THREE.SphereGeometry(height * 0.14), skin);
                    head.position.y = height * 0.65;
                    head.castShadow = true;
                    person.add(head);

                    // Face Features
                    // Eyes
                    [-0.045, 0.045].forEach(ex => {
                        const eye = new THREE.Mesh(new THREE.SphereGeometry(height * 0.015), black);
                        eye.position.set(ex * height, height * 0.68, height * 0.13);
                        person.add(eye);
                    });
                    // Smile
                    const mouth = new THREE.Mesh(new THREE.TorusGeometry(height * 0.04, height * 0.012, 8, 12, Math.PI), black);
                    mouth.position.set(0, height * 0.63, height * 0.13);
                    mouth.rotation.x = Math.PI;
                    person.add(mouth);

                    // Feet (Boots)
                    [-0.08, 0.08].forEach(fx => {
                        const foot = new THREE.Mesh(new THREE.CapsuleGeometry(height * 0.06, height * 0.12, 4, 8), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                        foot.position.set(fx * height, height * 0.02, height * 0.05);
                        foot.rotation.x = Math.PI / 2;
                        foot.castShadow = true;
                        person.add(foot);
                    });

                    // Scarf
                    const scarf = new THREE.Mesh(new THREE.TorusGeometry(height * 0.1, height * 0.03, 8, 16),
                        new THREE.MeshStandardMaterial({ color: isMe ? 0xff0000 : 0x00aa00 }));
                    scarf.position.y = height * 0.54;
                    scarf.rotation.x = Math.PI / 2;
                    person.add(scarf);

                    return person;
                };

                // "Me" (Tall figure) on the far LEFT
                const me = createPerson(2.2, 0x2c3e50, -1.2, true);
                props.family.add(me);
                // Mom
                props.family.add(createPerson(1.85, 0xc0392b, -0.1, false));
                // Kid
                const kid = createPerson(1.1, 0x27ae60, 0.8, false);
                props.family.add(kid);
                props.family.kid = kid;

                props.family.visible = false;
                scene.add(props.family);
            }

            // Scene 5: Reindeer
            function createReindeer() {
                props.reindeer = new THREE.Group();
                props.reindeer.position.set(3, -2.5, 4);
                const brown = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
                const darkBrown = new THREE.MeshStandardMaterial({ color: 0x5D3A1A });
                const red = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.3 });

                // Body
                const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 0.8, 8, 12), brown);
                body.rotation.z = Math.PI / 2;
                body.position.y = 0.6;
                props.reindeer.add(body);

                // Head
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.25), brown);
                head.position.set(0.7, 0.9, 0);
                props.reindeer.add(head);
                props.reindeer.head = head;

                // Snout
                const snout = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.12, 0.25), brown);
                snout.position.set(0.95, 0.85, 0);
                snout.rotation.z = Math.PI / 2;
                props.reindeer.add(snout);

                // Red Nose (Rudolph!)
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.08), red);
                nose.position.set(1.1, 0.85, 0);
                props.reindeer.add(nose);
                props.reindeer.nose = nose;

                // Eyes
                [-0.1, 0.1].forEach(z => {
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                    eye.position.set(0.85, 1.0, z);
                    props.reindeer.add(eye);
                });

                // Antlers
                [-0.15, 0.15].forEach(z => {
                    const antler = new THREE.Group();
                    antler.position.set(0.6, 1.1, z);

                    const main = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.04, 0.4), darkBrown);
                    main.rotation.z = z > 0 ? 0.3 : -0.3;
                    antler.add(main);

                    // Branches
                    const branch1 = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, 0.2), darkBrown);
                    branch1.position.set(z > 0 ? 0.1 : -0.1, 0.15, 0);
                    branch1.rotation.z = z > 0 ? 0.8 : -0.8;
                    antler.add(branch1);

                    props.reindeer.add(antler);
                });

                // Legs
                [[-0.3, -0.15], [-0.3, 0.15], [0.3, -0.15], [0.3, 0.15]].forEach(([x, z]) => {
                    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.06, 0.5), brown);
                    leg.position.set(x, 0.15, z);
                    props.reindeer.add(leg);
                });

                // Tail
                const tail = new THREE.Mesh(new THREE.SphereGeometry(0.08), brown);
                tail.position.set(-0.6, 0.7, 0);
                props.reindeer.add(tail);

                props.reindeer.visible = false;
                scene.add(props.reindeer);
            }

            // Typing Effect Helper
            function typeWriter(element, text, speed = 50, callback) {
                let i = 0;
                let chars = Array.from(text); // Correctly handles multi-byte characters like emojis
                element.textContent = ""; // Use textContent to preserve all whitespace
                element.classList.add('typing-cursor');
                function type() {
                    if (i < chars.length) {
                        element.textContent += chars[i];
                        i++;
                        setTimeout(type, speed);
                    } else {
                        element.classList.remove('typing-cursor');
                        if (callback) callback();
                    }
                }
                type();
            }

            const poses = {
                wave: () => {
                    elf.userData.isPosing = true;
                    elf.rotation.y %= (Math.PI * 2);
                    // Scene 1: Slow, welcoming entrance
                    gsap.to(elf.position, { x: 0.5, y: -3, z: 6, duration: 1.5, ease: "power2.out", overwrite: true });
                    gsap.to(elf.rotation, { x: 0, y: 0, z: 0, duration: 1.2, ease: "power2.out", overwrite: true });

                    // WALK ANIMATION while moving
                    const walkDur = 0.35;
                    const walkReps = Math.ceil(1.5 / walkDur);
                    gsap.to(elf.position, { y: "-=0.15", duration: walkDur / 2, repeat: walkReps * 2, yoyo: true, ease: "sine.inOut" });
                    gsap.to(elf.legL.rotation, { x: 0.5, duration: walkDur / 2, repeat: walkReps * 2, yoyo: true, ease: "sine.inOut" });
                    gsap.to(elf.legR.rotation, { x: -0.5, duration: walkDur / 2, repeat: walkReps * 2, yoyo: true, ease: "sine.inOut" });
                    gsap.to(elf.armL.rotation, { x: -0.3, duration: walkDur / 2, repeat: walkReps * 2, yoyo: true, ease: "sine.inOut" });

                    // Start wave AFTER walking
                    gsap.to(elf.armR.rotation, { z: 2.4, x: 0, duration: 0.6, delay: 1.2, ease: "back.out", overwrite: true });
                    gsap.to(elf.armR.rotation, { z: 3.0, duration: 0.4, repeat: -1, yoyo: true, delay: 1.8, ease: "sine.inOut" });

                    // EXPRESSION: Friendly welcoming smile
                    if (elf.mouth) {
                        gsap.to(elf.mouth.scale, { x: 1.2, y: 1.2, duration: 0.5, delay: 1.2, ease: "back.out" });
                        gsap.to(elf.mouth.rotation, { x: Math.PI / 1.1, duration: 0.5, delay: 1.2 }); // Normal smile
                    }
                },
                lookup: () => {
                    elf.userData.isPosing = true;
                    elf.rotation.y %= (Math.PI * 2);
                    // Scene 2: Gazing at the stars
                    gsap.to(elf.position, { x: -2, y: -3, z: 8, duration: 1.5, ease: "power2.out", overwrite: true });
                    gsap.to(elf.rotation, { y: 0, duration: 1.0, ease: "power2.out", overwrite: true });
                    gsap.to(elf.headJoint.rotation, { x: -0.5, duration: 1.5, repeat: -1, yoyo: true, ease: "sine.inOut" });
                    gsap.to([elf.armL.rotation, elf.armR.rotation], { z: 1.0, x: 0, duration: 0.8, ease: "power2.out", overwrite: true });
                    // EXPRESSION: Wonderous/reflective - smaller, thoughtful mouth
                    if (elf.mouth) {
                        gsap.to(elf.mouth.scale, { x: 0.6, y: 0.8, duration: 0.8, ease: "power2.out" });
                    }

                    // Santa Animation for Scene 2
                    if (props.santa) {
                        // Gentle float inside sleigh
                        gsap.to(props.santa.position, { y: 0.1, duration: 2, repeat: -1, yoyo: true, ease: "sine.inOut" });
                        // Position BOTH arms naturally (holding sleigh)
                        gsap.to([props.santa.armL.rotation, props.santa.armR.rotation], { z: 0.4, x: -0.5, duration: 1.0, ease: "power2.out" });

                        // Santa Wave (High Wave) with smoother transition
                        if (props.santa.armR) {
                            gsap.to(props.santa.armR.rotation, { z: 2.6, x: 0, duration: 1.2, ease: "back.out", delay: 1.0 });
                            gsap.to(props.santa.armR.rotation, { z: 3.0, duration: 0.6, repeat: -1, yoyo: true, delay: 2.2, ease: "sine.inOut" });
                        }
                    }
                },
                dance: () => {
                    elf.userData.isPosing = true;
                    elf.rotation.y %= (Math.PI * 2);
                    // Scene 3: Excited about gifts - arms swing FORWARD (negative x)
                    gsap.to(elf.position, { x: -3.5, y: -3, z: 3, duration: 1.2, ease: "power2.out", overwrite: true });
                    gsap.to(elf.rotation, { x: 0, y: Math.PI / 2 + 0.4, z: 0, duration: 1.0, ease: "power2.out", overwrite: true });

                    // Arms forward clap motion (negative x = forward)
                    gsap.to(elf.armL.rotation, { z: 0.3, x: -0.8, duration: 0.3, repeat: -1, yoyo: true, ease: "power1.inOut", overwrite: true });
                    gsap.to(elf.armR.rotation, { z: -0.3, x: -0.8, duration: 0.3, repeat: -1, yoyo: true, delay: 0.15, ease: "power1.inOut", overwrite: true });
                    // EXPRESSION: Big joyful smile - emotional climax!
                    if (elf.mouth) {
                        gsap.to(elf.mouth.scale, { x: 1.5, y: 1.3, duration: 0.6, ease: "elastic.out(1, 0.5)" });
                        gsap.to(elf.mouth.position, { y: 0.12, duration: 0.5 }); // Slightly lower for bigger smile
                    }
                },
                sit: () => {
                    elf.userData.isPosing = true;
                    elf.rotation.y %= (Math.PI * 2);
                    // Scene 4: Cozy sitting in front of snowman
                    // Lower him significantly so he sits ON the ground
                    gsap.to(elf.position, { x: 5, y: -3.85, z: 3.5, duration: 1.2, ease: "power2.out", overwrite: true });
                    gsap.to(elf.rotation, { x: 0, y: 0, z: 0, duration: 1.0, ease: "power2.out", overwrite: true });

                    // Legs fold forward properly and spread slightly
                    gsap.to(elf.legL.rotation, { x: -Math.PI / 2, y: -0.2, duration: 0.8, ease: "power2.out", overwrite: true });
                    gsap.to(elf.legR.rotation, { x: -Math.PI / 2, y: 0.2, duration: 0.8, ease: "power2.out", overwrite: true });

                    // Lean the upper body slightly back for a relaxed sit
                    if (elf.upperBody) {
                        gsap.to(elf.upperBody.rotation, { x: -0.15, duration: 0.8, ease: "power2.out" });
                    }

                    // Gentle happy leg waggle
                    gsap.to([elf.legL.rotation, elf.legR.rotation], { x: -1.3, duration: 1.5, repeat: -1, yoyo: true, delay: 0.8, ease: "sine.inOut" });

                    // EXPRESSION: Content peaceful smile
                    if (elf.mouth) {
                        gsap.to(elf.mouth.scale, { x: 1.0, y: 0.9, duration: 0.8, ease: "power2.out" });
                        gsap.to(elf.mouth.position, { y: 0.15, duration: 0.5 }); // Reset position
                    }
                },
                bow: () => {
                    elf.userData.isPosing = true;
                    elf.rotation.y %= (Math.PI * 2);
                    // Scene 5: Graceful bow facing camera, side by side with Santa
                    gsap.to(elf.position, { x: 1.2, y: -3, z: 5.5, duration: 1.2, ease: "power2.out", overwrite: true });
                    gsap.to(elf.rotation, { x: 0, y: -0.2, z: 0, duration: 1.0, ease: "power2.out", overwrite: true });

                    if (elf.upperBody) {
                        gsap.to(elf.upperBody.rotation, { x: 0.6, duration: 1.2, repeat: -1, yoyo: true, delay: 1.2, ease: "sine.inOut" });
                    } else {
                        gsap.to(elf.rotation, { x: 0.5, duration: 1.2, repeat: -1, yoyo: true, delay: 1.2, ease: "sine.inOut" });
                    }

                    // Arms behind back for bow
                    gsap.to([elf.armL.rotation, elf.armR.rotation], { z: 0.5, x: 0.3, duration: 0.8, delay: 0.5, ease: "power2.out", overwrite: true });
                    // EXPRESSION: Proud, grateful smile
                    if (elf.mouth) {
                        gsap.to(elf.mouth.scale, { x: 1.3, y: 1.1, duration: 0.6, ease: "power2.out" });
                        gsap.to(elf.mouth.position, { y: 0.15, duration: 0.5 });
                    }

                    // Force Santa Alignment in Scene 5
                    if (props.santa) {
                        scene.add(props.santa);
                        props.santa.visible = true;
                        gsap.killTweensOf(props.santa.position);
                        props.santa.position.set(-1.2, -3, 5.5);
                        props.santa.rotation.set(0, 0.2, 0);

                        // Santa Wave (High Wave)
                        if (props.santa.armR) {
                            gsap.killTweensOf(props.santa.armR.rotation);
                            gsap.to(props.santa.armR.rotation, { z: 2.6, x: 0, duration: 0.8, ease: "back.out" });
                            gsap.to(props.santa.armR.rotation, { z: 3.0, duration: 0.4, repeat: -1, yoyo: true, delay: 0.8, ease: "sine.inOut" });
                        }
                    }
                },
                reset: () => {
                    elf.userData.isPosing = false;
                    gsap.killTweensOf([elf.position, elf.rotation, elf.armL.rotation, elf.armR.rotation, elf.legL.rotation, elf.legR.rotation, elf.headJoint.rotation]);
                    if (elf.upperBody) gsap.killTweensOf(elf.upperBody.rotation);
                    if (props.santa) {
                        gsap.killTweensOf([props.santa.position, props.santa.rotation]);
                        if (props.santa.armR) gsap.killTweensOf(props.santa.armR.rotation);
                        if (props.santa.mouth) gsap.killTweensOf([props.santa.mouth.scale, props.santa.mouth.position, props.santa.mouth.rotation]);
                    }
                    if (elf.mouth) gsap.killTweensOf([elf.mouth.scale, elf.mouth.position, elf.mouth.rotation]);
                    gsap.to(elf.position, { y: -3, duration: 0.5, ease: "power2.out", overwrite: true });
                    gsap.to(elf.rotation, { x: 0, z: 0, duration: 0.5, ease: "power2.out", overwrite: true });
                    if (elf.upperBody) gsap.to(elf.upperBody.rotation, { x: 0, y: 0, z: 0, duration: 0.5 });
                    gsap.to([elf.armL.rotation, elf.armR.rotation, elf.legL.rotation, elf.legR.rotation, elf.headJoint.rotation], { x: 0, y: 0, z: 0, duration: 0.5, ease: "power2.out", overwrite: true });
                    // Reset expression
                    if (elf.mouth) {
                        gsap.to(elf.mouth.scale, { x: 1, y: 1, duration: 0.3 });
                        gsap.to(elf.mouth.position, { y: 0.15, duration: 0.3 });
                    }
                    if (props.santa && props.santa.mouth) {
                        gsap.to(props.santa.mouth.scale, { x: 1, y: 1, duration: 0.3 });
                    }
                    if (props.santa) {
                        if (props.santa.armL) gsap.to(props.santa.armL.rotation, { x: 0, y: 0, z: 0.3, duration: 0.5 });
                        if (props.santa.armR) gsap.to(props.santa.armR.rotation, { x: 0, y: 0, z: -0.3, duration: 0.5 });
                    }
                }
            };



            function nextScene() {
                if (!appState.isPlaying) return;

                // Check if we just finished the last scene
                if (appState.idx === script.length - 1) {
                    showFinale();
                    return;
                }

                const nextIdx = (appState.idx + 1) % script.length;
                const data = script[nextIdx];
                document.getElementById('current-scene').innerText = nextIdx + 1;

                const overlay = document.getElementById('book-overlay');
                const bL = document.getElementById('book-l');
                const bR = document.getElementById('book-r');

                const tl = gsap.timeline();
                tl.set(overlay, { visibility: 'visible' });

                if (appState.idx === -1) {
                    // FIRST START: Skip closing, update scene and just open
                    gsap.set([bL, bR], { x: "0%", rotateY: 0 });
                    gsap.to('#book-cover-title', { opacity: 0, duration: 0.5 }); // Hide cover title
                    appState.idx = nextIdx;
                    prepareSceneEnvironment(data);
                    tl.to(bL, { rotateY: -110, x: "-100%", duration: 1.5, ease: "power3.inOut", delay: 0.5 })
                        .to(bR, { rotateY: 110, x: "100%", duration: 1.5, ease: "power3.inOut" }, "-=1.5")
                        .to(['#book-spine', '#book-clasp', '#book-ribbon', '#book-spine-glow'], { opacity: 0, duration: 0.8, ease: "power2.inOut" }, "-=1.5") // Fade spine out as pages open
                        .set(overlay, { visibility: 'hidden' })
                        .add(() => {
                            // 5 SECONDS VIEWING DELAY BEFORE UI & TEXT
                            gsap.delayedCall(5, () => {
                                // Show UI (indicator and countdown)
                                document.getElementById('scene-indicator').style.display = 'block';
                                document.getElementById('countdown-box').style.display = 'flex';
                                gsap.fromTo(['.countdown-box', '.scene-indicator', '.timer-line', '#ui-layer'], { opacity: 0 }, { opacity: 1, duration: 1.5 });

                                // Start animations (Timer will be triggered inside unboxing)
                                startSceneAnimations(data);
                            });
                        });
                } else {
                    // NORMAL TRANSITION: Close then Open
                    tl.set(['#book-text-l', '#book-text-r'], { opacity: 1 }) // Show greeting text during transition
                        .fromTo(bL, { x: "-100%", rotateY: -90 }, { x: "0%", rotateY: 0, duration: 1.2, ease: "power3.inOut" })
                        .fromTo(bR, { x: "100%", rotateY: 90 }, { x: "0%", rotateY: 0, duration: 1.2, ease: "power3.inOut" }, "<")
                        .to(['#book-spine', '#book-clasp', '#book-ribbon', '#book-spine-glow'], { opacity: 1, duration: 0.8, ease: "power2.inOut" }, "<") // Fade spine in as pages close
                        .add(() => {
                            appState.idx = nextIdx;
                            prepareSceneEnvironment(data);
                        }, 1.2)
                        .to(bL, { rotateY: -110, x: "-100%", duration: 1.5, ease: "power3.inOut", delay: 0.3 })
                        .to(bR, { rotateY: 110, x: "100%", duration: 1.5, ease: "power3.inOut" }, "-=1.5")
                        .to(['#book-spine', '#book-clasp', '#book-ribbon', '#book-spine-glow'], { opacity: 0, duration: 0.8, ease: "power2.inOut" }, "-=1.5") // Fade spine out again
                        .to(['#book-text-l', '#book-text-r'], { opacity: 0, duration: 0.5 }, "-=1.0") // Hide again as it opens
                        .add(() => { startSceneAnimations(data); }, "-=1.0") // Start anims as it opens
                        .set(overlay, { visibility: 'hidden' });
                }

                // Removed immediate timer start: will be triggered by startSceneAnimations -> unboxTl
            }

            function emitFinaleMagic() {
                const container = document.getElementById('finale-magic-container');
                if (!container) return;

                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;

                // 1. Christmas Snow Burst
                for (let i = 0; i < 60; i++) {
                    const snow = document.createElement('div');
                    snow.className = 'finale-magic particle-snow-burst';
                    container.appendChild(snow);

                    const angle = Math.random() * Math.PI * 2;
                    const dist = 50 + Math.random() * 200;
                    const tx = Math.cos(angle) * dist;
                    const ty = Math.sin(angle) * dist - 100;

                    gsap.set(snow, { x: centerX, y: centerY, scale: 0 });
                    gsap.to(snow, {
                        x: centerX + tx,
                        y: centerY + ty,
                        scale: Math.random() * 1.5 + 0.5,
                        opacity: 1,
                        duration: 1 + Math.random() * 2,
                        ease: "power2.out",
                        onComplete: () => {
                            gsap.to(snow, { y: "-=200", opacity: 0, duration: 2, delay: 0.5, onComplete: () => snow.remove() });
                        }
                    });
                }

                // 2. New Year Firework Burst
                setTimeout(() => {
                    for (let i = 0; i < 100; i++) {
                        const star = document.createElement('div');
                        star.className = 'finale-magic particle-firework';
                        container.appendChild(star);

                        const angle = Math.random() * Math.PI * 2;
                        const velocity = 5 + Math.random() * 15;
                        const tx = Math.cos(angle) * velocity * 40;
                        const ty = Math.sin(angle) * velocity * 40;

                        gsap.set(star, { x: centerX, y: centerY, scale: 0 });
                        gsap.to(star, {
                            x: centerX + tx,
                            y: centerY + ty,
                            scale: Math.random() * 0.8 + 0.2,
                            duration: 2 + Math.random() * 1.5,
                            ease: "expo.out",
                            onComplete: () => star.remove()
                        });
                        gsap.to(star, {
                            opacity: 0,
                            duration: 1.5,
                            delay: 1 + Math.random(),
                            ease: "power2.in"
                        });
                    }
                }, 500);
            }

            function showFinale() {
                appState.isPlaying = false;
                appState.isFinale = true;
                const overlay = document.getElementById('book-overlay');
                const bL = document.getElementById('book-l');
                const bR = document.getElementById('book-r');
                const finale = document.getElementById('finale-msg');
                const tlTextL = document.getElementById('book-text-l');
                const tlTextR = document.getElementById('book-text-r');
                const flash = document.getElementById('finale-flash');

                // Clear UI and 3D Scene
                gsap.to(['#ui-layer', '.countdown-box', '.scene-indicator', '.hud', '.timer-line', '#canvas-container'], { opacity: 0, duration: 1.5, ease: "power2.inOut" });

                // Final Book Closing Sequence
                const masterTl = gsap.timeline();

                masterTl.set(overlay, { visibility: 'visible' })
                    .add(() => {
                        tlTextL.innerText = "The End";
                        tlTextR.innerText = "of the Story";
                    })
                    // Close the pages
                    .fromTo(bL, { x: "-100%", rotateY: -90 }, { x: "0%", rotateY: 0, duration: 2.2, ease: "power4.inOut" })
                    .fromTo(bR, { x: "100%", rotateY: 90 }, { x: "0%", rotateY: 0, duration: 2.2, ease: "power4.inOut" }, 0)
                    .to(['#book-spine', '#book-clasp', '#book-ribbon', '#book-spine-glow'], { opacity: 1, duration: 1.5 }, 0.5)

                    // The MAGIC MOMENT - exactly as the book snaps shut
                    .add(() => {
                        // Impact Flash
                        gsap.to(flash, { opacity: 0.8, duration: 0.1, yoyo: true, repeat: 1 });
                        emitFinaleMagic();
                    }, 1.8)

                    .to(finale, { opacity: 1, y: -20, duration: 2, ease: "back.out(1.7)" }, 2.0)
                    .to([tlTextL, tlTextR], { opacity: 0, duration: 1 }, 1.5);
            }

            function prepareSceneEnvironment(data) {
                document.body.style.background = data.bg;
                if (scene.fog) scene.fog.color.set(data.bg);
                props.stars.visible = (data.bg === "#0c1445");
                props.aurora.visible = (data.bg === "#0c1445");
                gsap.to(cameraGroup.position, { x: data.camTarget.x, y: data.camTarget.y, z: data.camTarget.z, duration: 3.5, ease: "power2.inOut" });

                // Reset character visibility
                if (props.puppy) props.puppy.visible = false;
                if (props.santa) props.santa.visible = false;
                if (props.gingerbread) props.gingerbread.visible = false;
                if (props.family) props.family.visible = false;
                if (props.reindeer) props.reindeer.visible = false;

                const sceneIdx = appState.idx;
                if (sceneIdx === 0 && props.puppy) props.puppy.visible = true;
                if (sceneIdx === 1 && props.santa) {
                    props.santa.visible = true;
                    // Reset sleigh position to start from left when Scene 2 begins
                    if (props.sleigh) {
                        props.sleigh.position.x = -45;
                    }
                    // Ensure Santa is in the sleigh for Scene 2
                    if (props.sleigh && props.santa.parent !== props.sleigh) {
                        props.sleigh.add(props.santa);
                        // Adjustment for new leg height: Santa sits deeper in sleigh
                        props.santa.position.set(0, -0.8, 0);
                        props.santa.rotation.set(0, -Math.PI / 2, 0);
                    }
                }
                if (sceneIdx === 2 && props.gingerbread) props.gingerbread.visible = true;
                if (sceneIdx === 3 && props.family) props.family.visible = true;
                if (sceneIdx === 4) {
                    if (props.reindeer) props.reindeer.visible = true;
                    if (props.santa) {
                        props.santa.visible = true;
                        // Move Santa to ground near elf in Scene 5 (Side by side)
                        scene.add(props.santa);
                        props.santa.position.set(-1.2, -3, 5.5);
                        props.santa.rotation.set(0, 0.2, 0);
                    }
                }

                poses.reset();

                // Reset presents
                presents.forEach(p => {
                    if (p.lid) {
                        gsap.killTweensOf(p.lid.position);
                        gsap.killTweensOf(p.lid.rotation);
                        p.lid.position.set(0, p.lidBaseY, 0);
                        p.lid.rotation.set(0, 0, 0);
                    }
                    if (p.light) {
                        gsap.killTweensOf(p.light);
                        p.light.intensity = 0;
                    }
                });
            }

            function startSceneAnimations(data) {
                const sceneIdx = appState.idx;
                const titleEl = document.getElementById('msg-title');
                const subEl = document.getElementById('msg-sub');
                const textWrap = document.getElementById('text-node');
                const photoBox = document.getElementById('photo-box');
                const glint = document.getElementById('photo-glint');

                // TEXT ANIMATION - Delay until unboxed
                titleEl.innerHTML = '';
                subEl.innerHTML = '';
                gsap.killTweensOf(textWrap);
                gsap.set(textWrap, { opacity: 0, y: 30, scale: 0.95 });

                const revealText = () => {
                    if (sceneIdx === 2) {
                        gsap.to(textWrap, { opacity: 1, y: 0, scale: 1, duration: 0.8, ease: "power4.out" });
                        gsap.to(textWrap, { scale: 1.02, duration: 0.5, yoyo: true, repeat: -1, ease: "sine.inOut", delay: 1 });
                    } else if (sceneIdx === 4) {
                        gsap.to(textWrap, { opacity: 1, y: 0, scale: 1, duration: 1.8, ease: "elastic.out(1, 0.5)" });
                    } else {
                        gsap.to(textWrap, { opacity: 1, y: 0, scale: 1, duration: 1.2, ease: "back.out(1.2)" });
                    }

                    const typingSpeed = sceneIdx === 2 ? 80 : (sceneIdx === 4 ? 50 : 60);
                    typeWriter(titleEl, data.title, typingSpeed, () => {
                        setTimeout(() => { typeWriter(subEl, data.sub, sceneIdx === 2 ? 50 : 40); }, sceneIdx === 2 ? 600 : 400);
                    });
                    gsap.to(textWrap, { y: "-=5", duration: 3, yoyo: true, repeat: -1, ease: "sine.inOut", delay: 1.5 });
                };

                // PHOTO REVEAL ANIMATION
                const photoImg = document.getElementById('photo-img');
                const photoAura = document.getElementById('photo-aura');
                const photoCont = document.getElementById('photo-box');
                const giftLid = document.getElementById('gift-lid');
                const giftBase = document.getElementById('gift-base');

                gsap.killTweensOf([photoBox, glint, photoImg, photoAura, giftLid, giftBase]);

                if (sceneIdx === 0) {
                    // --- 1. RESET BOX STATE ---
                    const giftGlow = document.getElementById('gift-glow');
                    const giftBow = document.getElementById('gift-bow');

                    gsap.set(giftBase, { opacity: 1, scale: 1, z: 0, y: 0, rotationX: 0, rotationY: 0 });
                    gsap.set(giftLid, { opacity: 1, scale: 1, z: 0, y: 0, rotationX: 0, rotationY: 0, rotationZ: 0 });
                    gsap.set(giftGlow, { opacity: 0 });
                    gsap.set(photoBox, {
                        opacity: 0,
                        scale: 0.5,
                        z: -50,
                        y: 80,
                        rotationY: 0,
                        rotationX: 0
                    });
                    gsap.set(photoImg, { filter: "blur(30px) brightness(2)" });
                    gsap.set(photoAura, { opacity: 0, scale: 0.3 });

                    // --- 2. DRAMATIC UNBOXING SEQUENCE ---
                    const unboxTl = gsap.timeline({ delay: 0.3 });

                    // PHASE 1: Anticipation - Box wobbles like something wants to escape
                    unboxTl.to(giftLid, {
                        y: -3,
                        duration: 0.15,
                        repeat: 5,
                        yoyo: true,
                        ease: "power1.inOut"
                    })
                        // PHASE 2: Inner glow intensifies
                        .to(giftGlow, {
                            opacity: 1,
                            duration: 0.4,
                            ease: "power2.in"
                        }, "-=0.3")
                        // PHASE 3: Lid pops off dramatically with rotation
                        .to(giftLid, {
                            y: -350,
                            z: 250,
                            rotationX: -65,
                            rotationY: 35,
                            rotationZ: 15,
                            scale: 0.9,
                            opacity: 0,
                            duration: 1.4,
                            ease: "power4.out",
                            onStart: () => {
                                const rect = photoCont.getBoundingClientRect();
                                // Burst of sparkles when lid pops
                                emitSparkles(rect.left + rect.width / 2, rect.top - 30, 35);
                                emitSparkles(rect.left + 20, rect.top, 15);
                                emitSparkles(rect.left + rect.width - 20, rect.top, 15);
                            }
                        })
                        // PHASE 4: Photo rises majestically from the box
                        .to(photoBox, {
                            opacity: 1,
                            scale: 1.05,
                            z: 150,
                            y: -50,
                            duration: 1.2,
                            ease: "back.out(1.5)",
                            onStart: () => {
                                gsap.delayedCall(0.3, revealText);
                                startChapterTimer();
                                // More sparkles as gift emerges
                                const rect = photoCont.getBoundingClientRect();
                                emitSparkles(rect.left + rect.width / 2, rect.top + rect.height / 2, 20);
                            }
                        }, "-=0.8")
                        // PHASE 5: Box fades away elegantly
                        .to(giftBase, {
                            opacity: 0,
                            scale: 0.85,
                            y: 80,
                            z: -100,
                            rotationX: 15,
                            duration: 1.2,
                            ease: "power3.in"
                        }, "-=0.9")
                        // PHASE 6: Photo settles into final position
                        .to(photoBox, {
                            scale: 1,
                            z: 0,
                            y: 0,
                            duration: 1.5,
                            ease: "elastic.out(1, 0.6)"
                        }, "-=0.4")
                        // PHASE 7: Image develops/unblurs
                        .to(photoImg, {
                            filter: "blur(0px) brightness(1)",
                            duration: 2.5,
                            ease: "power2.out"
                        }, "-=1.8");

                } else {
                    // --- CINEMATIC REVEAL FOR SUBSEQUENT SCENES ---
                    gsap.set([giftLid, giftBase], { opacity: 0 });
                    gsap.set(photoBox, {
                        opacity: 0,
                        scale: 0.1,
                        rotationY: -180,
                        z: -300,
                        y: 50
                    });
                    gsap.set(photoImg, { filter: "blur(40px) brightness(2)" });
                    gsap.set(photoAura, { opacity: 0, scale: 0.5 });

                    gsap.to(photoBox, {
                        opacity: 1,
                        scale: 1,
                        rotationY: 0,
                        z: 0,
                        y: 0,
                        duration: 1.8,
                        ease: "expo.out",
                        onStart: () => {
                            const rect = photoCont.getBoundingClientRect();
                            emitSparkles(rect.left + rect.width / 2, rect.top + rect.height / 2, 10);
                            revealText();
                            startChapterTimer();
                        }
                    });

                    gsap.to(photoImg, {
                        filter: "blur(0px) brightness(1)",
                        duration: 2.0,
                        ease: "power2.inOut"
                    });
                }

                // Magical Aura Glow (Looping)
                gsap.to(photoAura, {
                    opacity: 1,
                    scale: 1.3,
                    duration: 2.0,
                    yoyo: true,
                    repeat: -1,
                    ease: "sine.inOut"
                });

                // Glint Sweep (Looping)
                gsap.set(glint, { left: "-100%" });
                gsap.to(glint, {
                    left: "200%",
                    duration: 2.0,
                    delay: 2.5,
                    repeat: -1,
                    repeatDelay: 3.0,
                    ease: "power3.inOut"
                });

                // Subtle bobbing (separate from entrance)
                gsap.to(photoBox, { y: -15, duration: 4.5, yoyo: true, repeat: -1, ease: "sine.inOut", delay: 3 });

                // DECOS
                [1, 2, 3].forEach((n, i) => {
                    const d = document.getElementById(`deco-${n}`); d.innerText = data.decos[i];
                    gsap.killTweensOf(d);
                    gsap.set(d, { scale: 0, opacity: 0, rotation: -45 });
                    gsap.to(d, { scale: 1.2, opacity: 1, delay: 0.5 + i * 0.2, duration: 0.8, ease: "back.out(2)" });
                    gsap.to(d, { rotation: (i % 2 === 0 ? 15 : -15), duration: 2.5 + i, yoyo: true, repeat: -1, ease: "sine.inOut", delay: 1.5 });
                    gsap.to(d, { y: "-=10", duration: 3, yoyo: true, repeat: -1, ease: "sine.inOut", delay: 0.5 + i * 0.5 });
                });

                // CHARACTER ACTIONS
                if (sceneIdx === 0 && props.puppy) {
                    gsap.to(props.puppy.position, { x: 0.2, duration: 2, repeat: -1, yoyo: true, ease: "power1.inOut" });
                    gsap.to(props.puppy.position, { y: -2.6, duration: 0.3, repeat: -1, yoyo: true });
                    gsap.to(props.puppy.tail.rotation, { z: -1.5, duration: 0.15, repeat: -1, yoyo: true });
                }
                if (sceneIdx === 1 && props.santa) {
                    gsap.from(props.santa.scale, { x: 0, y: 0, z: 0, duration: 1, ease: "back.out" });
                    gsap.to(props.santa.rotation, { y: 0.2, duration: 2, repeat: -1, yoyo: true, ease: "sine.inOut" });
                    gsap.to(props.santa.head.rotation, { y: 0.3, duration: 1.2, repeat: -1, yoyo: true });
                }
                if (sceneIdx === 2 && props.gingerbread) {
                    gsap.to(props.gingerbread.position, { y: -2.2, duration: 0.3, repeat: -1, yoyo: true });
                    gsap.to(props.gingerbread.rotation, { y: 0.3, duration: 0.5, repeat: -1, yoyo: true });
                    gsap.to(props.gingerbread.armL.rotation, { z: 1.5, duration: 0.4, repeat: -1, yoyo: true });
                    gsap.to(props.gingerbread.armR.rotation, { z: -1.5, duration: 0.4, repeat: -1, yoyo: true, delay: 0.2 });

                    // Open Presents in Scene 3
                    presents.forEach((p, i) => {
                        if (p.lid) {
                            gsap.to(p.lid.position, {
                                y: 3 + Math.random() * 2,
                                x: (Math.random() - 0.5) * 4,
                                z: (Math.random() - 0.5) * 4,
                                duration: 1.2,
                                ease: "power2.out",
                                delay: 0.8 + i * 0.15
                            });
                            gsap.to(p.lid.rotation, {
                                x: Math.random() * 8,
                                y: Math.random() * 8,
                                duration: 2,
                                delay: 0.8 + i * 0.15
                            });
                            if (p.light) {
                                gsap.to(p.light, { intensity: 2, duration: 0.8, delay: 1.0 + i * 0.15 });
                            }
                        }
                    });
                }
                if (sceneIdx === 3 && props.family) {
                    if (props.family.kid) gsap.to(props.family.kid.position, { y: 0.2, duration: 0.5, repeat: -1, yoyo: true });
                }
                if (sceneIdx === 4 && props.reindeer) {
                    gsap.to(props.reindeer.position, { y: -2.3, duration: 0.5, repeat: -1, yoyo: true });
                    gsap.to(props.reindeer.head.rotation, { y: 0.2, duration: 1, repeat: -1, yoyo: true });
                    if (props.reindeer.nose) gsap.to(props.reindeer.nose.material, { emissiveIntensity: 1.0, duration: 0.5, repeat: -1, yoyo: true });
                }

                if (poses[data.charPose]) poses[data.charPose]();
            }

            document.getElementById('go-btn').onclick = () => {
                const btn = document.getElementById('go-btn');
                btn.style.pointerEvents = 'none'; // Prevent double click
                document.getElementById('bgm').play().catch(() => { });

                const tlOpen = gsap.timeline();

                // 1. Strings Snapping (0s - 1.0s)
                tlOpen.to(['.seal-string-left', '.seal-string-right'], {
                    scaleX: 0,
                    duration: 0.4,
                    ease: "elastic.in(1, 0.5)",
                    stagger: 0.1
                })
                    .to('.seal-curl', { opacity: 0, duration: 0.5, scale: 2 }, "<")

                    // 2. Seal Breaking (0.5s - 1.5s)
                    .to('.play-btn', {
                        rotation: 15,
                        scale: 1.2,
                        duration: 0.3,
                        ease: "back.out(3)"
                    }, "-=0.2") // Tension
                    .to('.play-btn', {
                        y: 800,
                        rotation: 180,
                        opacity: 0,
                        duration: 1.0,
                        ease: "power3.in"
                    }) // Fall

                    // 3. Dust & Title Fade (1.5s - 3.5s)
                    .add(() => emitBookDust(), "-=0.5")
                    .to(['#start-overlay h1', '.cinematic-sub', '.hint-text'], {
                        opacity: 0,
                        y: -50,
                        duration: 2,
                        ease: "power2.inOut",
                        stagger: 0.2
                    }, "-=0.8")

                    // 4. Reveal Book & Start (3.5s - 5.0s)
                    .to('#start-overlay', {
                        opacity: 0,
                        duration: 1.5,
                        onComplete: () => {
                            document.getElementById('start-overlay').style.display = 'none';
                            document.getElementById('total-scenes').innerText = script.length;
                            init3D();
                            appState.isPlaying = true;
                            nextScene();
                        }
                    }, "-=1.0");
            };



            // Anticipation / "Thinking" Peek Logic
            function initAnticipation() {
                const bL = document.getElementById('book-l');
                const bR = document.getElementById('book-r');
                const glow = document.getElementById('book-spine-glow');

                const peek = () => {
                    if (appState.idx !== -1) return; // Only on home screen

                    const tl = gsap.timeline();
                    // 1. Shiver of anticipation
                    // 1. Shiver of anticipation
                    tl.to([bL, bR], { x: (i) => i === 0 ? -1 : 1, duration: 0.1, repeat: 5, yoyo: true })
                        // 2. The Peek / Tease
                        .to(bL, { x: -8, duration: 0.8, ease: "power2.out" }, "+=0.1")
                        .to(bR, { x: 8, duration: 0.8, ease: "power2.out" }, "<")
                        .to(glow, { opacity: 0.8, scaleX: 3, duration: 0.8 }, "<")
                        // 3. Close back up
                        .to([bL, bR], { x: 0, duration: 1.2, ease: "power3.inOut" })
                        .to(glow, { opacity: 0, scaleX: 1, duration: 1.2 }, "-=1.2");

                    // Schedule next peek (5 to 12 seconds later)
                    gsap.delayedCall(Math.random() * 7 + 5, peek);
                };

                // Start the cycle
                gsap.delayedCall(4, peek);
            }



            function animate() {
                if (appState.isFinale) return; // Stop rendering when book closes for good
                requestAnimationFrame(animate);
                if (!renderer) return;
                const time = clock.getElapsedTime();
                // Snow Animation
                if (props.snow) {
                    const pos = props.snow.geometry.attributes.position.array;
                    for (let i = 1; i < pos.length; i += 3) {
                        pos[i] -= 0.03;
                        if (pos[i] < -10) pos[i] = 20;
                    }
                    props.snow.geometry.attributes.position.needsUpdate = true;
                }

                if (props.sparkles) props.sparkles.children.forEach(s => { s.scale.setScalar(0.5 + Math.sin(time * s.userData.speed + s.userData.phase) * 0.5); s.rotation.y += 0.03; });
                if (props.stars && props.stars.visible) props.stars.children.forEach(s => { s.scale.setScalar(0.8 + Math.sin(time * s.userData.twinkleSpeed + s.userData.phase) * 0.3); });

                // Twinkling Tree Lights (Simple)
                trees.forEach(t => {
                    t.rotation.z = Math.sin(time * 0.5 + t.userData.phase) * 0.02;
                    t.children.forEach(c => {
                        if (c.userData.isTreeLight) {
                            c.material.emissiveIntensity = 0.5 + Math.sin(time * 3 + c.userData.phase) * 0.3;
                        }
                    });
                });
                presents.forEach(p => { p.position.y = p.userData.baseY + Math.sin(time * 1.5 + p.userData.phase) * 0.08; p.rotation.y = Math.sin(time * 0.8 + p.userData.phase) * 0.05; });
                if (props.candyCanes) props.candyCanes.children.forEach(c => { c.rotation.z = Math.sin(time * 1.2 + c.userData.phase) * 0.08; });
                if (snowman) {
                    snowman.rotation.y = Math.sin(time * 0.3) * 0.05;
                    // Snowman comes alive!
                    if (snowman.face) {
                        snowman.face.rotation.y = Math.sin(time * 0.5) * 0.1; // Slow head turn
                    }
                    // Arm waving
                    if (snowman.armL) snowman.armL.rotation.z = Math.sin(time * 1.5) * 0.15;
                    if (snowman.armR) snowman.armR.rotation.z = Math.sin(time * 1.5 + 1) * -0.15;
                    // Scarf tail blowing
                    if (snowman.scarfTail) snowman.scarfTail.rotation.x = Math.sin(time * 2) * 0.2;
                    // Occasional blink
                    if (snowman.eyeL && snowman.eyeR) {
                        const blinkCycle = Math.sin(time * 0.3);
                        if (blinkCycle > 0.98) {
                            snowman.eyeL.scale.y = 1;
                            snowman.eyeR.scale.y = 1;
                        } else {
                            snowman.eyeL.scale.y = 0;
                            snowman.eyeR.scale.y = 0;
                        }
                    }
                }


                if (props.sleigh) {
                    props.sleigh.position.x += 0.12; // Much faster traveling speed
                    props.sleigh.position.y = 12 + Math.sin(time * 1.5) * 1.5;
                    props.sleigh.rotation.z = Math.sin(time * 1.5) * 0.1;
                    if (props.sleigh.position.x > 45) props.sleigh.position.x = -45; // Wider travel range
                    const spk = new THREE.Mesh(new THREE.OctahedronGeometry(0.12), new THREE.MeshBasicMaterial({ color: 0xffddaa, transparent: true, opacity: 0.8 }));
                    spk.position.copy(props.sleigh.position); spk.position.x -= 2; props.sleighTrail.add(spk);
                    gsap.to(spk.scale, { x: 0, y: 0, z: 0, duration: 2, onComplete: () => props.sleighTrail.remove(spk) });
                }
                if (props.aurora && props.aurora.visible) {
                    const pos = props.aurora.children[0].geometry.attributes.position.array;
                    for (let i = 0; i < pos.length; i += 3) { pos[i + 2] = Math.sin(time + pos[i] * 0.1) * 2; }
                    props.aurora.children[0].geometry.attributes.position.needsUpdate = true;
                }

                // ============ NEW LIFE ELEMENT ANIMATIONS ============

                // Floating Lanterns
                if (props.lanterns) {
                    props.lanterns.children.forEach(lantern => {
                        lantern.position.y += Math.sin(time * lantern.userData.speed + lantern.userData.phase) * 0.005;
                        lantern.position.x += lantern.userData.driftX;
                        lantern.rotation.y = Math.sin(time * 0.3 + lantern.userData.phase) * 0.2;
                        lantern.rotation.z = Math.sin(time * 0.5 + lantern.userData.phase) * 0.1;
                        // Reset lanterns that drift too far
                        if (lantern.position.x > 30) lantern.position.x = -30;
                        if (lantern.position.x < -30) lantern.position.x = 30;
                    });
                }

                // Proper Bunny Hopping with Leg Animation
                if (props.bunnies) {
                    props.bunnies.children.forEach(bunny => {
                        // Resting behavior
                        if (bunny.userData.isResting) {
                            bunny.userData.idleTime += 0.016;
                            // Nose twitch
                            if (bunny.nose) bunny.nose.scale.x = 1 + Math.sin(time * 8) * 0.15;
                            // Ear rotation
                            if (bunny.earL) bunny.earL.rotation.x = Math.sin(time * 2) * 0.1;
                            if (bunny.earR) bunny.earR.rotation.x = Math.sin(time * 2 + 0.5) * 0.1;
                            // Start hopping again after rest
                            if (bunny.userData.idleTime > 3 + Math.random() * 4) {
                                bunny.userData.isResting = false;
                                bunny.userData.idleTime = 0;
                                bunny.userData.direction = Math.random() * Math.PI * 2;
                            }
                            return;
                        }

                        const hopPhase = time * bunny.userData.hopSpeed + bunny.userData.hopPhase;
                        const hopHeight = Math.max(0, Math.sin(hopPhase));
                        const isInAir = hopHeight > 0.1;

                        // Position
                        bunny.position.y = -2.85 + hopHeight * 0.4;

                        // Move forward only when hopping
                        if (isInAir) {
                            bunny.position.x += Math.cos(bunny.userData.direction) * 0.025;
                            bunny.position.z += Math.sin(bunny.userData.direction) * 0.025;
                        }

                        // Face direction
                        bunny.rotation.y = bunny.userData.direction;

                        // Squash and stretch body
                        const squash = isInAir ? 1.1 : 0.9;
                        const stretch = isInAir ? 0.85 : 1.15;
                        bunny.scale.set(0.35 * stretch, 0.35 * squash, 0.35 * stretch);

                        // Leg animation
                        if (bunny.backLegL) {
                            bunny.backLegL.rotation.x = isInAir ? -0.5 : 0.3;
                            bunny.backLegR.rotation.x = isInAir ? -0.5 : 0.3;
                        }
                        if (bunny.frontLegL) {
                            bunny.frontLegL.rotation.x = isInAir ? 0.3 : -0.2;
                            bunny.frontLegR.rotation.x = isInAir ? 0.3 : -0.2;
                        }

                        // Ear flop
                        if (bunny.earL) {
                            bunny.earL.rotation.x = -0.25 + (isInAir ? -0.2 : 0.1);
                            bunny.earR.rotation.x = -0.25 + (isInAir ? -0.2 : 0.1);
                        }

                        // Nose twitch
                        if (bunny.nose) bunny.nose.scale.x = 1 + Math.sin(time * 12) * 0.1;

                        // Tail wiggle
                        if (bunny.tail) bunny.tail.position.x = Math.sin(time * 6) * 0.02;

                        // Boundary check - stop and rest
                        if (Math.abs(bunny.position.x) > 22 || Math.abs(bunny.position.z) > 18) {
                            bunny.userData.isResting = true;
                            bunny.userData.direction += Math.PI + (Math.random() - 0.5);
                        }

                        // Random rest
                        if (Math.random() < 0.001) bunny.userData.isResting = true;
                    });
                }

                // Fireflies
                if (props.fireflies) {
                    props.fireflies.children.forEach(ff => {
                        ff.position.x += Math.sin(time * ff.userData.speed + ff.userData.phase) * 0.02;
                        ff.position.y += Math.cos(time * ff.userData.speed * 0.7 + ff.userData.phase) * 0.015;
                        ff.position.z += Math.sin(time * ff.userData.speed * 0.5 + ff.userData.phase + 1) * 0.02;
                        // Pulsing glow
                        ff.material.opacity = 0.4 + Math.sin(time * 3 + ff.userData.phase) * 0.4;
                        ff.scale.setScalar(0.8 + Math.sin(time * 4 + ff.userData.phase) * 0.3);
                    });
                }

                // Flying Owls with Swooping Motion
                if (props.owls) {
                    props.owls.children.forEach(owl => {
                        // Swooping flight path
                        owl.position.x += owl.userData.speed * owl.userData.direction;
                        owl.position.y = owl.userData.baseY + Math.sin(time * 0.8 + owl.position.x * 0.05) * 1.2;

                        // Banking turns
                        owl.rotation.z = Math.sin(time * 0.8 + owl.position.x * 0.05) * 0.15 * owl.userData.direction;

                        // Face direction of travel
                        owl.rotation.y = owl.userData.direction === 1 ? Math.PI / 2 : -Math.PI / 2;

                        // Wrap around screen
                        if (owl.position.x > 50) owl.position.x = -50;
                        if (owl.position.x < -50) owl.position.x = 50;

                        // Wing flapping (faster when climbing)
                        const climbRate = Math.cos(time * 0.8 + owl.position.x * 0.05);
                        const flapSpeed = 6 + Math.abs(climbRate) * 4;
                        if (owl.wingL) owl.wingL.rotation.z = Math.sin(time * flapSpeed) * 0.5;
                        if (owl.wingR) owl.wingR.rotation.z = -Math.sin(time * flapSpeed) * 0.5;
                    });
                }

                // Elf Walking Logic
                if (elf && !elf.userData.isPosing) {
                    const walkSpeed = 0.8;
                    const radius = 3.5;
                    const angle = time * 0.4;

                    // Circular path around the center
                    elf.position.x = Math.cos(angle) * radius;
                    elf.position.z = Math.sin(angle) * radius + 2; // Offset slightly
                    elf.rotation.y = (-angle) % (Math.PI * 2); // Normalized rotation to prevent spinning fast on transitions

                    // Bobbing motion
                    elf.position.y = -3 + Math.abs(Math.sin(time * 3)) * 0.15;

                    // Leg Swing
                    elf.legL.rotation.x = Math.sin(time * 5) * 0.5;
                    elf.legR.rotation.x = Math.sin(time * 5 + Math.PI) * 0.5;

                    // Arm Swing
                    elf.armL.rotation.x = Math.sin(time * 5 + Math.PI) * 0.3;
                    elf.armR.rotation.x = Math.sin(time * 5) * 0.3;
                }

                if (window.cameraGroup) {
                    // Update camera position within its group for interactive drift
                    camera.position.x = Math.cos(time * 0.3) * 0.002 + (currentMouseX * 0.2);
                    camera.position.y = Math.sin(time * 0.4) * 0.003 + (-currentMouseY * 0.1);
                    // Subtle rotation follow
                    camera.rotation.y = currentMouseX * 0.02;
                    camera.rotation.x = -currentMouseY * 0.01;
                }

                // Update Parallax with Lerp
                if (typeof targetMouseX !== 'undefined') {
                    currentMouseX += (targetMouseX - currentMouseX) * 0.1;
                    currentMouseY += (targetMouseY - currentMouseY) * 0.1;

                    const photoImg = document.getElementById('photo-img');
                    const photoBox = document.getElementById('photo-box');

                    if (photoImg) {
                        photoImg.style.transform = `scale(1.15) translate(${currentMouseX * 10}px, ${currentMouseY * 10}px)`;
                    }
                    if (photoBox) {
                        photoBox.style.transform = `perspective(1000px) rotateY(${currentMouseX * 5}deg) rotateX(${-currentMouseY * 5}deg)`;
                    }
                }

                if (renderer && scene && camera) renderer.render(scene, camera);
            }
            window.addEventListener('resize', () => { if (!camera || !renderer) return; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            // Start anticipation peeks immediately while on home screen
            initAnticipation();

            // Create light intro snow
            const introContainer = document.getElementById('intro-sparkles');
            for (let i = 0; i < 25; i++) {
                const s = document.createElement('div');
                s.className = 'snowflake-intro';
                s.style.left = Math.random() * 100 + '%';
                s.style.top = Math.random() * 100 + '%';
                s.style.width = s.style.height = (Math.random() * 5 + 2) + 'px';
                s.style.animationDelay = (Math.random() * 10) + 's';
                s.style.animationDuration = (Math.random() * 5 + 10) + 's';
                introContainer.appendChild(s);
            }

            // Unlock audio on interaction
            // Unlock audio on interaction
            const unlockAudio = () => {
                document.getElementById('bgm').play().catch(() => { });
                document.removeEventListener('click', unlockAudio);
            };
            document.addEventListener('click', unlockAudio);

            // ============ PARALLAX EFFECT FOR PHOTO FRAME ============
            window.targetMouseX = 0;
            window.targetMouseY = 0;
            window.currentMouseX = 0;
            window.currentMouseY = 0;

            document.addEventListener('mousemove', (e) => {
                targetMouseX = (e.clientX / window.innerWidth - 0.5) * 2;
                targetMouseY = (e.clientY / window.innerHeight - 0.5) * 2;
            });

            document.addEventListener('mouseleave', () => {
                targetMouseX = 0;
                targetMouseY = 0;
            });

        })();
    </script>
</body>

</html>