<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holiday Magic Show</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&family=Mountains+of+Christmas:wght@700&family=Pacifico&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --gold: #ffd700;
            --white: #ffffff;
            --red: #d63031;
            --green: #1a472a;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Fredoka', sans-serif;
            color: var(--white);
            user-select: none;
            transition: background 1.5s ease;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            perspective: 1200px;
        }

        .photo-stage {
            position: relative;
            transform-style: preserve-3d;
            margin-bottom: 80px;
            /* Increased space for clarity */
        }

        .photo-container {
            width: 280px;
            height: 280px;
            border: 8px solid rgba(255, 255, 255, 0.95);
            border-radius: 18px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 30px rgba(255, 215, 0, 0.2);
            overflow: hidden;
            background: #111;
            position: relative;
            z-index: 5;
        }

        .photo-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: blur(45px) contrast(1.1) brightness(1.2);
            /* Heavy blur as requested */
            transform: scale(1.1);
            /* Prevent edge bleeding from blur */
        }

        .photo-glint {
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.6), transparent);
            transform: skewX(-25deg);
        }

        .deco {
            position: absolute;
            font-size: 3.5rem;
            filter: drop-shadow(0 10px 10px rgba(0, 0, 0, 0.4));
            z-index: 10;
            opacity: 0;
            transform: scale(0);
        }

        .text-wrap {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            color: var(--red);
            padding: 40px 60px;
            /* More breathing room */
            border-radius: 30px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.5);
            text-align: center;
            max-width: 85%;
            min-width: 400px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-bottom: 8px solid var(--red);
            opacity: 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .main-msg {
            font-family: 'Mountains of Christmas', cursive;
            font-size: 2.2rem;
            display: inline-block;
            min-height: 2.5rem;
        }

        .sub-msg {
            font-size: 1.1rem;
            color: #444;
            font-weight: 400;
            display: inline-block;
            min-height: 1.5rem;
        }

        /* Cursor for typing effect */
        .typing-cursor {
            border-right: 3px solid var(--red);
            animation: blink 0.7s infinite;
        }

        @keyframes blink {

            0%,
            100% {
                border-color: transparent;
            }

            50% {
                border-color: var(--red);
            }
        }

        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            /* Above the book overlay */
            background: transparent;
            /* Show the book underneath */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            perspective: 500px;
            /* For 3D text effects */
        }

        /* HERO TITLE: Holiday Express */
        #start-overlay h1 {
            font-family: 'Mountains of Christmas', cursive;
            font-size: 6rem;
            /* Much Bigger */
            margin: 0 0 10px 0;
            color: #ffffff;
            text-shadow:
                0 0 10px rgba(255, 215, 0, 0.5),
                0 0 30px rgba(255, 215, 0, 0.3),
                0 10px 40px rgba(0, 0, 0, 0.8);
            transform: translateZ(50px);
            letter-spacing: 2px;
            animation: heroFloat 6s ease-in-out infinite;
        }

        @keyframes heroFloat {

            0%,
            100% {
                transform: translateY(0) translateZ(50px);
            }

            50% {
                transform: translateY(-10px) translateZ(50px);
            }
        }

        /* CINEMATIC TAGLINE */
        .cinematic-sub {
            font-size: 1.4rem;
            margin-bottom: 60px;
            font-weight: 400;
            letter-spacing: 8px;
            /* High spacing */
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            text-transform: uppercase;
        }

        .hint-text {
            margin-top: 25px;
            font-family: 'Fredoka', sans-serif;
            font-size: 0.9rem;
            color: rgba(255, 215, 0, 0.7);
            letter-spacing: 1px;
            opacity: 0;
            animation: fadeInHint 2s ease-out forwards 1s;
        }

        @keyframes fadeInHint {
            to {
                opacity: 1;
            }
        }

        /* Wax Seal Button with Strings */
        .seal-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .seal-string {
            position: absolute;
            height: 4px;
            /* Twisted Twine Look */
            background: repeating-linear-gradient(45deg, #8B0000, #8B0000 5px, #5a0000 5px, #5a0000 10px);
            top: 50%;
            transform: translateY(-50%);
            z-index: -1;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        /* Festive Curls/Hair strings */
        .seal-curl {
            position: absolute;
            border: 1px solid #8B0000;
            border-radius: 50%;
            pointer-events: none;
            z-index: -2;
            opacity: 0.6;
            animation: curlSway 6s infinite ease-in-out alternate;
        }

        @keyframes curlSway {
            0% {
                transform: rotate(0deg) scale(1);
            }

            100% {
                transform: rotate(15deg) scale(1.1);
            }
        }

        .seal-string-left {
            right: 50%;
            width: 50vw;
            border-radius: 3px 0 0 3px;
        }

        .seal-string-right {
            left: 50%;
            width: 50vw;
            border-radius: 0 3px 3px 0;
        }

        .play-btn {
            background: radial-gradient(circle at 35% 35%, #b21e1e, #5a0909);
            color: #ffca28;
            /* Brighter gold */
            border: none;
            cursor: pointer;
            /* Authentic "Melted" Wax Shape */
            border-radius: 48% 52% 51% 49% / 54% 45% 55% 46%;
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.8),
                inset 0 0 15px rgba(0, 0, 0, 0.5),
                /* Inner shadow for depth */
                inset 0 0 0 8px #9b1c1c;
            /* The outer rim/lip of the wax seal */
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto;
            position: relative;
            z-index: 10;
            width: 150px;
            height: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            animation: sealBreath 6s infinite ease-in-out;
        }

        /* Dramatic Breathing & Shimmer */
        @keyframes sealBreath {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1) drop-shadow(0 0 0px rgba(255, 215, 0, 0));
            }

            50% {
                transform: scale(1.05);
                filter: brightness(1.1) drop-shadow(0 0 15px rgba(255, 215, 0, 0.3));
            }
        }

        .play-btn::after {
            /* Gold Sparkle Rim pulsing */
            content: "";
            position: absolute;
            top: -5px;
            bottom: -5px;
            left: -5px;
            right: -5px;
            border-radius: 50%;
            border: 1px solid rgba(255, 215, 0, 0.3);
            opacity: 0;
            animation: rimFlash 5s infinite;
        }

        @keyframes rimFlash {
            40% {
                opacity: 0;
                transform: scale(1);
            }

            50% {
                opacity: 0.8;
                transform: scale(1.1);
            }

            60% {
                opacity: 0;
                transform: scale(1);
            }
        }

        .play-btn::before {
            content: "üîí";
            font-size: 1.5rem;
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.4));
            margin-bottom: 2px;
            display: block;
        }

        @keyframes sealGlow {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.02);
                filter: brightness(1.15);
            }
        }

        .play-btn:hover {
            transform: scale(1.08) rotate(-3deg);
            filter: brightness(1.1);
        }

        .seal-text {
            font-size: 0.95rem;
            font-family: 'Fredoka', sans-serif;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-weight: 600;
            color: #ffd700;
            text-align: center;
            max-width: 100px;
            line-height: 1.2;
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.8);
        }

        .timer-line {
            position: fixed;
            top: 0;
            left: 0;
            height: 8px;
            background: linear-gradient(to right, var(--gold), #fff, var(--gold));
            width: 0%;
            z-index: 60;
            box-shadow: 0 0 15px var(--gold);
        }

        .countdown-box {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 50;
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-size: 1.1rem;
            display: none;
            align-items: center;
            gap: 10px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }

        .countdown-box span {
            font-weight: 700;
            font-size: 1.4rem;
            color: var(--gold);
        }

        .scene-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 50;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 0.9rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: none;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }

        /* Storybook Transition */
        #book-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 500;
            pointer-events: none;
            display: flex;
            visibility: visible;
            perspective: 2000px;
            animation: bookBreathing 8s infinite ease-in-out;
        }

        /* Spine with stitching & LIGHT SWEEP */
        #book-spine {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 20px;
            transform: translateX(-50%);
            background: linear-gradient(90deg, #3d0a0a, #5a1010, #3d0a0a);
            z-index: 15;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        #book-spine::after {
            content: "";
            position: absolute;
            top: -50%;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(to bottom, transparent, rgba(255, 215, 0, 0.4), transparent);
            filter: blur(4px);
            animation: spineSweep 6s infinite ease-in-out;
        }

        @keyframes spineSweep {
            0% {
                top: -50%;
                opacity: 0;
            }

            30% {
                opacity: 1;
            }

            60% {
                top: 150%;
                opacity: 0;
            }

            100% {
                top: 150%;
                opacity: 0;
            }
        }

        /* Center Sparkle at intersection */
        .intersection-sparkle {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, #fff 0%, rgba(255, 215, 0, 0.8) 20%, transparent 70%);
            z-index: 12;
            /* Between seal and spine/string */
            mix-blend-mode: screen;
            filter: blur(2px);
            animation: sparklePulse 3s infinite alternate;
        }

        @keyframes sparklePulse {
            0% {
                opacity: 0.3;
                scale: 0.8;
            }

            100% {
                opacity: 0.8;
                scale: 1.2;
            }
        }

        #book-spine-glow {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 10px;
            transform: translateX(-50%);
            background: radial-gradient(ellipse at center, var(--gold), transparent 70%);
            filter: blur(8px);
            z-index: 5;
            opacity: 0;
            box-shadow: 0 0 40px var(--gold);
        }

        @keyframes bookBreathing {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.015);
            }

            /* Very subtle scale pulse */
        }

        /* Subtle Floating Dust/Sparkles for Home */
        #intro-sparkles {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            overflow: hidden;
        }

        .dust,
        .snowflake-intro {
            position: absolute;
            background: white;
            border-radius: 50%;
            opacity: 0.3;
            filter: blur(2px);
            pointer-events: none;
        }

        .dust {
            animation: floatDust 20s infinite linear;
        }

        .snowflake-intro {
            animation: fallIntro 18s infinite linear;
            opacity: 0.4;
        }

        @keyframes floatDust {
            100% {
                transform: translate(100px, -100px) scale(0.5);
                opacity: 0;
            }
        }

        .book-page {
            flex: 1;
            height: 100%;
            background: #5a1010;
            background-image:
                linear-gradient(180deg, rgba(0, 0, 0, 0.2) 0%, transparent 15%, transparent 85%, rgba(0, 0, 0, 0.3) 100%),
                radial-gradient(ellipse at 30% 30%, rgba(255, 255, 255, 0.08) 0%, transparent 50%),
                url("https://www.transparenttextures.com/patterns/leather.png");
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow:
                inset 0 0 180px rgba(0, 0, 0, 0.95),
                /* Deeper vignette */
                inset 0 0 450px rgba(0, 0, 0, 0.6);
            border: 5px solid #8B5A2B;
            border-image: linear-gradient(145deg, #d4af37, #8B5A2B, #d4af37) 1;
        }

        /* Gold embossed inner frame */
        .book-page::before {
            content: "";
            position: absolute;
            /* Gold embossed border */
            pointer-events: none;
            box-shadow: 0 0 10px rgba(183, 139, 5, 0.3);
        }

        /* Gold Corner Protectors */
        .book-corner {
            position: absolute;
            width: 50px;
            height: 50px;
            z-index: 20;
        }

        .book-corner::before,
        .book-corner::after {
            content: "";
            position: absolute;
            background: linear-gradient(135deg, #ffd700, #b8860b);
        }

        .book-corner::before {
            width: 100%;
            height: 4px;
        }

        .book-corner::after {
            width: 4px;
            height: 100%;
        }

        .corner-tl {
            top: 10px;
            left: 10px;
        }

        .corner-tr {
            top: 10px;
            right: 10px;
            transform: scaleX(-1);
        }

        .corner-bl {
            bottom: 10px;
            left: 10px;
            transform: scaleY(-1);
        }

        .corner-br {
            bottom: 10px;
            right: 10px;
            transform: scale(-1);
        }

        /* Gold Corners with Sway */
        .book-page::after {
            content: "‚öú";
            position: absolute;
            color: #d4af37;
            font-size: 2rem;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            animation: ornamentSway 4s infinite ease-in-out;
        }

        @keyframes ornamentSway {

            0%,
            100% {
                transform: rotate(0deg);
            }

            50% {
                transform: rotate(5deg);
            }
        }

        .book-left::after {
            bottom: 25px;
            left: 25px;
        }

        .book-right::after {
            bottom: 25px;
            right: 25px;
            transform: scaleX(-1);
        }

        .book-left::after {
            animation-delay: 0s;
        }

        .book-right::after {
            animation-delay: 1s;
        }

        .book-left {
            transform-origin: left;
        }

        .book-right {
            transform-origin: right;
        }

        .book-ornament {
            font-size: 5rem;
            opacity: 0.2;
            color: var(--gold);
            filter: grayscale(1) brightness(2);
            animation: ornamentSway 5s infinite ease-in-out alternate;
        }

        .shimmer-text {
            background: linear-gradient(90deg, #ffd700, #fff, #ffd700);
            background-size: 200% auto;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmerEffect 4s linear infinite;
        }

        @keyframes shimmerEffect {
            to {
                background-position: 200% center;
            }
        }

        .chapter-text {
            position: absolute;
            font-family: 'Mountains of Christmas', cursive;
            font-size: 3rem;
            color: var(--gold);
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            z-index: 10;
            opacity: 0;
            /* Hidden by default to avoid overlap with Start UI */
        }

        .hud {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 50;
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .hud-btn {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.4);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.4rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: 0.3s;
        }

        .hud-btn:hover {
            background: var(--red);
            border-color: white;
            transform: scale(1.1) rotate(5deg);
        }

        /* Start Overlay Title Hierarchy */
        #start-overlay h1 {
            font-family: 'Pacifico';
            font-size: 3.8rem;
            margin-bottom: 10px;
            color: white;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .cinematic-sub {
            font-size: 1.3rem;
            margin-bottom: 50px;
            font-weight: 300;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.8);
        }

        .hint-text {
            font-family: 'Fredoka', sans-serif;
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 30px;
            opacity: 0;
            animation: fadeInHint 2s ease-out forwards 2s;
        }

        /* Book Cover Title Subtle */
        #book-cover-title {
            position: absolute;
            top: 15%;
            width: 100%;
            text-align: center;
            z-index: 20;
            pointer-events: none;
            opacity: 1;
            /* More visible */
            transform: scale(1);
            transition: opacity 1s ease-in-out, transform 1s ease-in-out;
        }

        #book-cover-title .shimmer-text {
            font-family: 'Mountains of Christmas';
            font-size: 3.5rem;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.9);
            color: #ffd700;
            letter-spacing: 2px;
        }

        #book-cover-title div:last-child {
            font-size: 1rem;
            color: rgba(255, 215, 0, 0.8);
            letter-spacing: 8px;
            margin-top: 8px;
            text-transform: uppercase;
            font-weight: 700;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.7);
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>
    <div id="ui-layer">
        <div class="photo-stage" id="photo-stage">
            <div class="deco" id="deco-1" style="top: -50px; left: -50px;">üéÅ</div>
            <div class="deco" id="deco-2" style="top: -50px; right: -50px;">üéÄ</div>
            <div class="deco" id="deco-3" style="bottom: -60px; left: 50%; transform: translateX(-50%);">‚ú®</div>
            <div class="photo-container" id="photo-box">
                <div class="photo-glint" id="photo-glint"></div>
                <img src="{{ url_for('christmas.static', filename='avatar_true.jpg') }}" class="photo-img">
            </div>
        </div>
        <div class="text-wrap" id="text-node">
            <div class="main-msg" id="msg-title"></div>
            <div class="sub-msg" id="msg-sub"></div>
        </div>
    </div>
    <div id="start-overlay">
        <h1 style="">Holiday Express</h1>
        <p class="cinematic-sub">A 3D Cinematic Journey</p>

        <div class="seal-container">
            <!-- Center Sparkle for Magic -->
            <div class="intersection-sparkle"></div>

            <div class="seal-string seal-string-left"></div>
            <div class="seal-string seal-string-right"></div>

            <!-- Decorative "Hair" Curls -->
            <div class="seal-curl"
                style="width: 40px; height: 20px; left: -60px; top: -10px; border-bottom: 2px solid #8B0000; border-radius: 40% 60%;">
            </div>
            <div class="seal-curl"
                style="width: 30px; height: 40px; left: -40px; bottom: -20px; border-left: 2px solid #8B0000; border-radius: 60% 40%;">
            </div>
            <div class="seal-curl"
                style="width: 50px; height: 15px; right: -70px; top: 10px; border-top: 2px solid #8B0000; border-radius: 50% 50%;">
            </div>
            <div class="seal-curl"
                style="width: 25px; height: 35px; right: -30px; bottom: -15px; border-right: 2px solid #8B0000; border-radius: 30% 70%;">
            </div>

            <button class="play-btn" id="go-btn">
                <span class="seal-text">Open Just<br>For You</span>
            </button>
        </div>
        <div class="hint-text">‚ú® A short cinematic experience awaits ‚ú®</div>
    </div>
    <div class="countdown-box" id="countdown-box">‚è±Ô∏è Showing for: <span id="countdown-timer">1:40</span></div>
    <div class="scene-indicator" id="scene-indicator">Scene <span id="current-scene">1</span> / <span
            id="total-scenes">5</span></div>
    <div class="hud">
        <button class="hud-btn" id="btn-pause">‚è∏</button>
        <button class="hud-btn" id="btn-mute">üîä</button>
    </div>
    <div class="timer-line" id="timer"></div>
    <div id="book-overlay">
        <!-- Book Spine -->
        <div id="book-spine"></div>

        <!-- Ornate Clasp -->
        <div id="book-clasp">üîí</div>

        <!-- Ribbon Bookmark -->
        <div id="book-ribbon"></div>

        <!-- The Spine Glow (the "Thrill" leaking out) -->
        <div id="book-spine-glow"></div>

        <!-- Floating Discreet Dust -->
        <div id="intro-sparkles">
            <div class="dust" style="top: 20%; left: 10%; width: 5px; height: 5px; animation-duration: 25s;"></div>
            <div class="dust" style="top: 60%; left: 30%; width: 8px; height: 8px; animation-duration: 18s;"></div>
            <div class="dust" style="top: 40%; left: 80%; width: 4px; height: 4px; animation-duration: 22s;"></div>
            <div class="dust" style="top: 70%; left: 70%; width: 6px; height: 6px; animation-duration: 30s;"></div>
        </div>

        <!-- Decoration for the cover -->
        <div id="book-cover-title"
            style="position: absolute; top: 15%; width: 100%; text-align: center; z-index: 20; pointer-events: none; opacity: 0.7; transform: scale(0.9);">
            <div class="shimmer-text"
                style="font-family: 'Mountains of Christmas'; font-size: 3rem; text-shadow: 0 2px 10px rgba(0,0,0,0.6); color: #b8860b;">
                The Magic of Christmas</div>
            <div
                style="font-size: 0.9rem; color: rgba(255,215,0,0.5); letter-spacing: 6px; margin-top: 5px; text-transform: uppercase;">
                A
                Holiday Keepsake</div>
        </div>

        <div class="book-page book-left" id="book-l">
            <div class="book-ornament">üéÑ</div>
            <div class="chapter-text" id="book-text-l" style="right: 20px;">A Holiday Tale</div>
        </div>
        <div class="book-page book-right" id="book-r">
            <div class="book-ornament">‚ú®</div>
            <div class="chapter-text" id="book-text-r" style="left: 20px;">Just For You ‚ú®</div>
        </div>
        <!-- Finale Message (Hidden until end) -->
        <div id="finale-msg"
            style="position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; opacity: 0; pointer-events: none; text-align: center; padding: 40px;">
            <h1
                style="font-family: 'Mountains of Christmas', cursive; font-size: 5rem; color: var(--gold); margin-bottom: 20px; text-shadow: 0 5px 15px rgba(0,0,0,0.5);">
                Merry Christmas!</h1>
            <p style="font-family: 'Pacifico', cursive; font-size: 2.5rem; color: white;">& Advance Happy New Year!</p>
        </div>
    </div>
    <audio id="bgm" loop>
        <source src="{{ url_for('christmas.static', filename='Winter Book.mp3') }}" type="audio/mpeg">
    </audio>



    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        (function () {
            const DURATION = 20; // UPDATED: Last 20 seconds
            const script = [
                // Scene 1: INTRO - The Warm Welcome
                {
                    bg: "#1a472a",
                    title: "‚ú® To Someone Special ‚ú®",
                    sub: "This isn't just a greeting... it's a little piece of my heart, wrapped in winter magic, just for you.",
                    decos: ["üíù", "üåü", "‚ùÑÔ∏è"],
                    charPose: "wave",
                    camTarget: { x: 0, y: 4, z: 22 }
                },
                // Scene 2: RISING ACTION - Reflecting on the Journey
                {
                    bg: "#0c1445",
                    title: "üåô Looking Back at This Year üåô",
                    sub: "We've been through so much together... the laughter, the struggles, the little moments that meant everything.",
                    decos: ["‚≠ê", "üåô", "üí´"],
                    charPose: "lookup",
                    camTarget: { x: -4, y: 6, z: 20 }
                },
                // Scene 3: CLIMAX - The Emotional Core
                {
                    bg: "#5a2a2a",
                    title: "üíï You Mean the World to Me üíï",
                    sub: "I don't say it enough... but having you in my life is the greatest gift I could ever ask for.",
                    decos: ["üíñ", "ü•π", "‚ú®"],
                    charPose: "dance",
                    camTarget: { x: 4, y: 3, z: 21 }
                },
                // Scene 4: RESOLUTION - Comfort and Warmth
                {
                    bg: "#2d3436",
                    title: "üè† You Are My Home üè†",
                    sub: "No matter where life takes us, my heart will always find its way back to you. Always.",
                    decos: ["‚òï", "ü§ó", "üî•"],
                    charPose: "sit",
                    camTarget: { x: 0, y: 2, z: 18 }
                },
                // Scene 5: ENDING - Hope and Promise
                {
                    bg: "#b78b05",
                    title: "üåÖ Here's to Forever üåÖ",
                    sub: "May this new year bring you all the joy, love, and dreams your beautiful heart deserves. I'll be right here, cheering you on.",
                    decos: ["ü•Ç", "üéÜ", "üíõ"],
                    charPose: "bow",
                    camTarget: { x: 0, y: 5, z: 24 }
                }
            ];

            const TOTAL_TIME = script.length * DURATION;
            let timeRemaining = TOTAL_TIME, countdownInterval = null;
            let appState = { idx: -1, isPlaying: false };
            let scene, camera, renderer, elf, christmasTree, snowman, presents = [], props = {}, clock;
            let trees = [];

            function updateCountdown() {
                if (timeRemaining <= 0) { clearInterval(countdownInterval); return; }
                timeRemaining--;
                const mins = Math.floor(timeRemaining / 60), secs = timeRemaining % 60;
                document.getElementById('countdown-timer').innerText = `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            function init3D() {
                if (typeof THREE === 'undefined') { alert('Three.js failed. Please refresh.'); return; }
                clock = new THREE.Clock();
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x1a472a, 0.025);

                camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 5, 22);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);

                scene.add(new THREE.AmbientLight(0xffffff, 0.35));
                const mainLight = new THREE.DirectionalLight(0xfff8e0, 1.1);
                mainLight.position.set(8, 20, 10);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.set(2048, 2048);
                mainLight.shadow.camera.near = 1; mainLight.shadow.camera.far = 60;
                scene.add(mainLight);

                const fillLight = new THREE.PointLight(0xff8866, 0.6, 25);
                fillLight.position.set(-8, 4, 6);
                scene.add(fillLight);

                const rimLight = new THREE.PointLight(0x88ccff, 0.5, 20);
                rimLight.position.set(6, 3, -8);
                scene.add(rimLight);

                createGround();
                createForest();
                createSnowman();
                createPresents();
                createElf();
                createFloatingOrnaments();
                createSparkles();
                createSnow();
                createStars();
                createSleigh();
                createCandyCanes();
                createStringLights();
                createAurora();

                // NEW: More Life Elements
                createFloatingLanterns();
                createBunnies();
                createFireflies();
                createFlyingOwls();
                createGroundDecor();

                // Scene Characters
                createPuppy();
                createSanta();
                createGingerbread();
                createFamily();
                createReindeer();

                animate();
            }

            function createGround() {
                const geo = new THREE.PlaneGeometry(120, 120, 80, 80);
                const pos = geo.attributes.position.array;
                for (let i = 2; i < pos.length; i += 3) pos[i] += Math.random() * 0.2 - 0.1;
                geo.computeVertexNormals();
                const mat = new THREE.MeshStandardMaterial({ color: 0xf8f8ff, roughness: 0.95 });
                const ground = new THREE.Mesh(geo, mat);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -3;
                ground.receiveShadow = true;
                scene.add(ground);
            }

            function createTree(x, z, scale = 1, isMain = false) {
                const group = new THREE.Group();
                group.position.set(x, -3, z);
                group.scale.set(scale, scale, scale);

                // Enhanced Trunk with Roots
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.9 });
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.6, 2.2, 8), trunkMat);
                trunk.position.y = 1.1; trunk.castShadow = true;
                group.add(trunk);

                // Visible Roots
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const root = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.15, 0.8, 6), trunkMat);
                    root.position.set(Math.cos(angle) * 0.4, 0.2, Math.sin(angle) * 0.4);
                    root.rotation.z = Math.cos(angle) * 0.5;
                    root.rotation.x = Math.sin(angle) * 0.5;
                    group.add(root);
                }

                // Foliage - Multiple Layered Tiers
                const foliageColors = [0x1d5a2e, 0x2d6a3e, 0x1a4d28]; // Color variation
                const tiers = [[2.5, 3.0, 3.0], [2.0, 2.8, 5.0], [1.6, 2.5, 7.0], [1.1, 2.0, 8.8], [0.6, 1.5, 10.2]];

                tiers.forEach(([radius, height, yPos], tierIndex) => {
                    const tierGroup = new THREE.Group();
                    tierGroup.position.y = yPos;

                    // Main Cone Shape
                    const coneMat = new THREE.MeshStandardMaterial({ color: foliageColors[tierIndex % foliageColors.length], roughness: 0.8 });
                    const mainCone = new THREE.Mesh(new THREE.ConeGeometry(radius, height, 12), coneMat);
                    mainCone.castShadow = true;
                    tierGroup.add(mainCone);

                    // Branch Clusters (small cones around the main shape for detail)
                    const numBranches = 8 + tierIndex * 2;
                    for (let i = 0; i < numBranches; i++) {
                        const angle = (i / numBranches) * Math.PI * 2 + Math.random() * 0.3;
                        const branchRadius = radius * (0.3 + Math.random() * 0.2);
                        const branchHeight = height * (0.4 + Math.random() * 0.2);
                        const branchY = -height * 0.3 + Math.random() * height * 0.4;

                        const branch = new THREE.Mesh(
                            new THREE.ConeGeometry(branchRadius, branchHeight, 6),
                            new THREE.MeshStandardMaterial({ color: foliageColors[(tierIndex + 1) % foliageColors.length], roughness: 0.85 })
                        );
                        branch.position.set(Math.cos(angle) * radius * 0.7, branchY, Math.sin(angle) * radius * 0.7);
                        branch.rotation.z = Math.cos(angle) * 0.3;
                        branch.rotation.x = Math.sin(angle) * 0.3;
                        branch.castShadow = true;
                        tierGroup.add(branch);
                    }

                    // Snow Accents on Top Tiers
                    if (tierIndex >= 2 && Math.random() > 0.3) {
                        const snowMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
                        const snowCap = new THREE.Mesh(new THREE.ConeGeometry(radius * 0.5, height * 0.2, 8), snowMat);
                        snowCap.position.y = height * 0.4;
                        tierGroup.add(snowCap);
                    }
                    group.add(tierGroup);
                });

                if (isMain) {
                    // Star on Top
                    const starMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 1.5 });
                    const starGroup = new THREE.Group();
                    starGroup.position.y = 11.8;
                    for (let i = 0; i < 5; i++) {
                        const spike = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.8, 4), starMat);
                        spike.rotation.z = (i / 5) * Math.PI * 2; spike.position.y = 0.4;
                        starGroup.add(spike);
                    }
                    group.add(starGroup);
                    group.star = starGroup;

                    // Ornaments
                    const ornColors = [0xff0000, 0x0066ff, 0xffd700, 0x00cc44, 0xff69b4, 0x9900ff];
                    for (let i = 0; i < 45; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const h = 3 + Math.random() * 8;
                        const r = 0.5 + (11 - h) * 0.2;
                        const orn = new THREE.Mesh(new THREE.SphereGeometry(0.14, 16, 16),
                            new THREE.MeshStandardMaterial({ color: ornColors[Math.floor(Math.random() * ornColors.length)], metalness: 0.9, roughness: 0.1 }));
                        orn.position.set(Math.cos(angle) * r, h, Math.sin(angle) * r);
                        group.add(orn);
                    }

                    // Icicles hanging from branches
                    for (let i = 0; i < 15; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const h = 4 + Math.random() * 6;
                        const r = (11 - h) * 0.22;
                        const icicle = new THREE.Mesh(
                            new THREE.ConeGeometry(0.04, 0.3 + Math.random() * 0.3, 4),
                            new THREE.MeshStandardMaterial({ color: 0xaaddff, transparent: true, opacity: 0.7, metalness: 0.3 })
                        );
                        icicle.position.set(Math.cos(angle) * r, h - 0.5, Math.sin(angle) * r);
                        icicle.rotation.x = Math.PI; // Point downwards
                        group.add(icicle);
                    }

                    // String Lights wrapping the tree
                    const lightColors = [0xff0000, 0x00ff00, 0xffff00, 0x00ffff, 0xff00ff];
                    for (let i = 0; i < 60; i++) {
                        const angle = i * 0.4;
                        const h = 3 + i * 0.12;
                        const r = 0.6 + (11 - h) * 0.18;
                        if (h > 11) continue;
                        const light = new THREE.Mesh(
                            new THREE.SphereGeometry(0.06),
                            new THREE.MeshStandardMaterial({ color: lightColors[i % lightColors.length], emissive: lightColors[i % lightColors.length], emissiveIntensity: 0.8 })
                        );
                        light.position.set(Math.cos(angle) * r, h, Math.sin(angle) * r);
                        group.add(light);
                    }
                }

                group.userData.phase = Math.random() * Math.PI * 2;
                scene.add(group);
                trees.push(group);
                return group;
            }

            function createForest() {
                christmasTree = createTree(-5, -3, 1.1, true);
                for (let i = 0; i < 20; i++) {
                    const x = (Math.random() - 0.5) * 60;
                    const z = -10 - Math.random() * 30;
                    if (Math.abs(x) < 8 && z > -15) continue;
                    createTree(x, z, 0.5 + Math.random());
                }
            }

            function createSnowman() {
                snowman = new THREE.Group();
                snowman.position.set(5, -3, 1);
                scene.add(snowman);
                const snowMat = new THREE.MeshStandardMaterial({ color: 0xfafafa, roughness: 0.85 });
                const coalMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                [[1.3, 1.3], [1.0, 3.2], [0.7, 4.6]].forEach(([r, y]) => {
                    const ball = new THREE.Mesh(new THREE.SphereGeometry(r, 28, 28), snowMat);
                    ball.position.y = y; ball.castShadow = true; snowman.add(ball);
                });
                [[-0.22, 4.85, 0.58], [0.22, 4.85, 0.58]].forEach(([x, y, z]) => {
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.08), coalMat);
                    eye.position.set(x, y, z); snowman.add(eye);
                });
                const nose = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.65, 8), new THREE.MeshStandardMaterial({ color: 0xff6b00 }));
                nose.rotation.x = Math.PI / 2; nose.position.set(0, 4.55, 0.75); snowman.add(nose);
                [3.0, 3.3, 3.6].forEach(y => {
                    const btn = new THREE.Mesh(new THREE.SphereGeometry(0.1), coalMat);
                    btn.position.set(0, y, 0.95); snowman.add(btn);
                });
                const brim = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.12, 20), coalMat);
                brim.position.y = 5.3; snowman.add(brim);
                const top = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.45, 0.9, 20), coalMat);
                top.position.y = 5.8; snowman.add(top);
                const scarf = new THREE.Mesh(new THREE.TorusGeometry(0.65, 0.14, 8, 20), new THREE.MeshStandardMaterial({ color: 0xcc0000 }));
                scarf.position.y = 4.0; scarf.rotation.x = Math.PI / 2; snowman.add(scarf);
                const stickMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
                [-1, 1].forEach(side => {
                    const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.03, 1.8, 6), stickMat);
                    arm.position.set(side * 1.4, 3.3, 0); arm.rotation.z = side * 0.6; snowman.add(arm);
                });
            }

            function createPresents() {
                const positions = [[-6.5, 0.5], [-5.2, 1.2], [-4, 0.8], [4, 2.5], [5.5, 2], [6.5, 1.8]];
                const colors = [0xd63031, 0x0984e3, 0x00b894, 0x6c5ce7, 0xfdcb6e, 0xe84393];
                positions.forEach((pos, i) => {
                    const size = 0.5 + Math.random() * 0.5;
                    const group = new THREE.Group();
                    group.position.set(pos[0], -3 + size / 2, pos[1]);
                    group.userData.baseY = group.position.y;
                    group.userData.phase = Math.random() * Math.PI * 2;
                    const boxMat = new THREE.MeshStandardMaterial({ color: colors[i % colors.length], roughness: 0.5, metalness: 0.1 });
                    const box = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), boxMat);
                    box.castShadow = true; group.add(box);
                    const ribbonMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.7, roughness: 0.2 });
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(size * 0.12, size + 0.02, size + 0.02), ribbonMat));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(size + 0.02, size * 0.12, size + 0.02), ribbonMat));
                    const bow = new THREE.Mesh(new THREE.TorusGeometry(size * 0.15, size * 0.05, 8, 12), ribbonMat);
                    bow.position.y = size / 2 + 0.08; bow.rotation.x = Math.PI / 2; group.add(bow);
                    presents.push(group); scene.add(group);
                });
            }

            function createElf() {
                elf = new THREE.Group();
                elf.position.set(2.8, -3, 4); elf.rotation.y = -0.35;
                scene.add(elf);
                const skin = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.65 });
                const suit = new THREE.MeshStandardMaterial({ color: 0x27ae60, roughness: 0.55 });
                const red = new THREE.MeshStandardMaterial({ color: 0xe74c3c, roughness: 0.55 });
                const white = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.75 });
                const belt = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });

                // Create legs WITH boots attached (so they move together)
                const createLeg = (x) => {
                    const lg = new THREE.Group();
                    lg.position.set(x, 0.9, 0); // Hip pivot point

                    // Leg mesh (red pants)
                    const mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.13, 0.16, 0.9), red);
                    mesh.position.y = -0.45;
                    mesh.castShadow = true;
                    lg.add(mesh);

                    // Boot attached to leg
                    const boot = new THREE.Mesh(new THREE.CapsuleGeometry(0.18, 0.35, 8, 10), belt);
                    boot.position.y = -0.85; // Below the leg
                    boot.castShadow = true;
                    lg.add(boot);

                    return lg;
                };
                elf.legL = createLeg(-0.28); elf.legR = createLeg(0.28);
                elf.add(elf.legL); elf.add(elf.legR);

                const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.45, 1.15), suit);
                torso.position.y = 1.85; torso.castShadow = true; elf.add(torso);
                const beltMesh = new THREE.Mesh(new THREE.TorusGeometry(0.42, 0.07, 10, 20), belt);
                beltMesh.position.y = 1.4; beltMesh.rotation.x = Math.PI / 2; elf.add(beltMesh);
                const buckle = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.16, 0.06), new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8 }));
                buckle.position.set(0, 1.4, 0.42); elf.add(buckle);
                const collar = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.09, 10, 20), white);
                collar.position.y = 2.35; collar.rotation.x = Math.PI / 2; elf.add(collar);
                const headJoint = new THREE.Group(); headJoint.position.y = 2.6;
                elf.add(headJoint); elf.headJoint = headJoint;
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.45), skin);
                head.position.y = 0.25; head.castShadow = true; headJoint.add(head);
                [-0.4, 0.4].forEach(x => {
                    const ear = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.3, 8), skin);
                    ear.position.set(x, 0.3, 0); ear.rotation.z = x > 0 ? 0.6 : -0.6; headJoint.add(ear);
                });
                [-0.14, 0.14].forEach(x => {
                    const eyeW = new THREE.Mesh(new THREE.SphereGeometry(0.09), white);
                    eyeW.position.set(x, 0.32, 0.38); headJoint.add(eyeW);
                    const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.045), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                    pupil.position.set(x, 0.32, 0.46); headJoint.add(pupil);
                });

                // Mouth
                const mouth = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.03, 8, 12, Math.PI), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                mouth.position.set(0, 0.15, 0.45);
                mouth.rotation.x = Math.PI / 1.1;
                headJoint.add(mouth);
                elf.mouth = mouth;
                const hatBase = new THREE.Mesh(new THREE.CylinderGeometry(0.48, 0.48, 0.14, 18), white);
                hatBase.position.y = 0.7; headJoint.add(hatBase);
                const hatCone = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1.0), red);
                hatCone.position.y = 1.2; hatCone.rotation.x = 0.15; headJoint.add(hatCone);
                const pomPom = new THREE.Mesh(new THREE.SphereGeometry(0.14), white);
                pomPom.position.set(0, 1.65, 0.2); headJoint.add(pomPom);

                // Arms with proper pivot
                const createArm = (x) => {
                    const ag = new THREE.Group();
                    ag.position.set(x, 2.15, 0); // Shoulder pivot
                    const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.11, 0.55), suit);
                    upper.position.y = -0.25;
                    upper.castShadow = true;
                    ag.add(upper);
                    const hand = new THREE.Mesh(new THREE.SphereGeometry(0.13), skin);
                    hand.position.y = -0.55;
                    ag.add(hand);
                    return ag;
                };
                elf.armL = createArm(-0.5); elf.armR = createArm(0.5);
                elf.add(elf.armL); elf.add(elf.armR);
            }

            function createFloatingOrnaments() {
                props.floatingOrns = new THREE.Group();
                const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffd700, 0xff69b4];
                for (let i = 0; i < 15; i++) {
                    const orn = new THREE.Mesh(new THREE.SphereGeometry(0.15 + Math.random() * 0.1, 16, 16),
                        new THREE.MeshStandardMaterial({ color: colors[Math.floor(Math.random() * colors.length)], metalness: 0.85, roughness: 0.15 }));
                    orn.position.set((Math.random() - 0.5) * 25, 2 + Math.random() * 8, (Math.random() - 0.5) * 20 - 5);
                    orn.userData.speed = 0.3 + Math.random() * 0.5;
                    orn.userData.phase = Math.random() * Math.PI * 2;
                    props.floatingOrns.add(orn);
                }
                scene.add(props.floatingOrns);
            }

            function createSparkles() {
                props.sparkles = new THREE.Group();
                for (let i = 0; i < 40; i++) {
                    const s = new THREE.Mesh(new THREE.OctahedronGeometry(0.05), new THREE.MeshBasicMaterial({ color: 0xffffaa }));
                    s.position.set((Math.random() - 0.5) * 30, Math.random() * 15, (Math.random() - 0.5) * 25 - 5);
                    s.userData.speed = 1 + Math.random() * 2; s.userData.phase = Math.random() * Math.PI * 2;
                    props.sparkles.add(s);
                }
                scene.add(props.sparkles);
            }

            function createSnow() {
                props.snow = new THREE.Group();
                const geo = new THREE.BufferGeometry();
                const count = 3000;
                const pos = new Float32Array(count * 3);
                for (let i = 0; i < count * 3; i += 3) {
                    pos[i] = (Math.random() - 0.5) * 60; pos[i + 1] = Math.random() * 35; pos[i + 2] = (Math.random() - 0.5) * 60;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                props.snow.add(new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, transparent: true, opacity: 0.85 })));
                scene.add(props.snow);
            }

            function createStars() {
                props.stars = new THREE.Group();
                for (let i = 0; i < 80; i++) {
                    const star = new THREE.Mesh(new THREE.OctahedronGeometry(0.08 + Math.random() * 0.15), new THREE.MeshBasicMaterial({ color: 0xffffcc }));
                    star.position.set((Math.random() - 0.5) * 50, 12 + Math.random() * 25, (Math.random() - 0.5) * 40 - 15);
                    star.userData.twinkleSpeed = 2 + Math.random() * 3; star.userData.phase = Math.random() * Math.PI * 2;
                    props.stars.add(star);
                }
                scene.add(props.stars);
                props.stars.visible = false;
            }

            function createAurora() {
                props.aurora = new THREE.Group();
                const geo = new THREE.PlaneGeometry(80, 20, 20, 5);
                const mat = new THREE.MeshBasicMaterial({ color: 0x22ff88, transparent: true, opacity: 0.3, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
                const mesh = new THREE.Mesh(geo, mat); mesh.position.set(0, 15, -20); mesh.rotation.x = -0.5;
                props.aurora.add(mesh); scene.add(props.aurora); props.aurora.visible = false;
            }

            function createSleigh() {
                props.sleigh = new THREE.Group();
                props.sleigh.position.set(-25, 20, -15);
                props.sleigh.add(new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.6, 1.2), new THREE.MeshStandardMaterial({ color: 0xcc0000 })));
                props.sleighTrail = new THREE.Group(); scene.add(props.sleighTrail); scene.add(props.sleigh);
            }

            function createCandyCanes() {
                props.candyCanes = new THREE.Group();
                [[-8, 0], [-7, 2], [7, 1], [8, -1]].forEach(([x, z]) => {
                    const cane = new THREE.Group(); cane.position.set(x, -3, z);
                    const st = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 2), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                    st.position.y = 1; cane.add(st);
                    const crv = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.1, 8, 12, Math.PI), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                    crv.position.set(0.35, 2, 0); crv.rotation.z = Math.PI / 2; cane.add(crv);
                    for (let i = 0; i < 8; i++) {
                        const str = new THREE.Mesh(new THREE.TorusGeometry(0.12, 0.03, 6, 12), new THREE.MeshStandardMaterial({ color: 0xcc0000 }));
                        str.position.y = 0.3 + i * 0.25; str.rotation.x = Math.PI / 2; cane.add(str);
                    }
                    cane.userData.phase = Math.random() * Math.PI * 2; props.candyCanes.add(cane);
                });
                scene.add(props.candyCanes);
            }

            function createStringLights() {
                props.stringLights = new THREE.Group();
                const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
                for (let i = 0; i < 25; i++) {
                    const t = i / 24, x = -12 + t * 24, y = 8 + Math.sin(t * Math.PI) * 4, z = -8;
                    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.12),
                        new THREE.MeshStandardMaterial({ color: colors[i % colors.length], emissive: colors[i % colors.length], emissiveIntensity: 0.8 }));
                    bulb.position.set(x, y, z); bulb.userData.phase = i * 0.3; props.stringLights.add(bulb);
                }
                scene.add(props.stringLights);
            }

            // ============ NEW LIFE ELEMENTS ============

            // Floating Paper Lanterns
            function createFloatingLanterns() {
                props.lanterns = new THREE.Group();
                const lanternColors = [0xff6600, 0xffaa00, 0xff4444, 0xffcc00];
                for (let i = 0; i < 12; i++) {
                    const lantern = new THREE.Group();
                    const x = (Math.random() - 0.5) * 50;
                    const y = 8 + Math.random() * 12;
                    const z = (Math.random() - 0.5) * 40 - 10;
                    lantern.position.set(x, y, z);

                    // Lantern Body
                    const color = lanternColors[Math.floor(Math.random() * lanternColors.length)];
                    const body = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.4, 0.8, 8),
                        new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5, transparent: true, opacity: 0.85 })
                    );
                    lantern.add(body);

                    // Inner Glow
                    const glow = new THREE.Mesh(
                        new THREE.SphereGeometry(0.25),
                        new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0.6 })
                    );
                    lantern.add(glow);

                    // Top Cap
                    const cap = new THREE.Mesh(
                        new THREE.ConeGeometry(0.2, 0.2, 6),
                        new THREE.MeshStandardMaterial({ color: 0x4a3728 })
                    );
                    cap.position.y = 0.5;
                    lantern.add(cap);

                    lantern.userData.speed = 0.2 + Math.random() * 0.3;
                    lantern.userData.phase = Math.random() * Math.PI * 2;
                    lantern.userData.driftX = (Math.random() - 0.5) * 0.01;
                    props.lanterns.add(lantern);
                }
                scene.add(props.lanterns);
            }

            // Hopping Bunnies
            function createBunnies() {
                props.bunnies = new THREE.Group();
                const bunnyMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7 });
                const pinkMat = new THREE.MeshStandardMaterial({ color: 0xffcccc });

                for (let i = 0; i < 6; i++) {
                    const bunny = new THREE.Group();
                    const x = (Math.random() - 0.5) * 35;
                    const z = (Math.random() - 0.5) * 25;
                    bunny.position.set(x, -2.8, z);
                    bunny.scale.set(0.4, 0.4, 0.4);

                    // Body
                    const body = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), bunnyMat);
                    body.scale.set(1, 0.8, 1.2);
                    bunny.add(body);

                    // Head
                    const head = new THREE.Mesh(new THREE.SphereGeometry(0.35), bunnyMat);
                    head.position.set(0, 0.3, 0.5);
                    bunny.add(head);
                    bunny.head = head;

                    // Ears
                    [-0.15, 0.15].forEach(ex => {
                        const ear = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.4, 4, 8), bunnyMat);
                        ear.position.set(ex, 0.7, 0.45);
                        ear.rotation.x = -0.3;
                        bunny.add(ear);

                        const innerEar = new THREE.Mesh(new THREE.CapsuleGeometry(0.04, 0.3, 4, 8), pinkMat);
                        innerEar.position.set(ex, 0.7, 0.48);
                        innerEar.rotation.x = -0.3;
                        bunny.add(innerEar);
                    });

                    // Eyes
                    [-0.1, 0.1].forEach(ex => {
                        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                        eye.position.set(ex, 0.38, 0.78);
                        bunny.add(eye);
                    });

                    // Nose
                    const nose = new THREE.Mesh(new THREE.SphereGeometry(0.05), pinkMat);
                    nose.position.set(0, 0.28, 0.82);
                    bunny.add(nose);

                    // Tail
                    const tail = new THREE.Mesh(new THREE.SphereGeometry(0.15), bunnyMat);
                    tail.position.set(0, 0.1, -0.55);
                    bunny.add(tail);

                    bunny.userData.hopPhase = Math.random() * Math.PI * 2;
                    bunny.userData.hopSpeed = 1.5 + Math.random();
                    bunny.userData.direction = Math.random() * Math.PI * 2;
                    props.bunnies.add(bunny);
                }
                scene.add(props.bunnies);
            }

            // Fireflies / Magic Particles
            function createFireflies() {
                props.fireflies = new THREE.Group();
                for (let i = 0; i < 50; i++) {
                    const firefly = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05 + Math.random() * 0.05),
                        new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0.8 })
                    );
                    firefly.position.set(
                        (Math.random() - 0.5) * 50,
                        1 + Math.random() * 10,
                        (Math.random() - 0.5) * 40
                    );
                    firefly.userData.speed = 0.5 + Math.random();
                    firefly.userData.phase = Math.random() * Math.PI * 2;
                    firefly.userData.orbitRadius = 0.5 + Math.random() * 2;
                    props.fireflies.add(firefly);
                }
                scene.add(props.fireflies);
            }

            // Flying Owls
            function createFlyingOwls() {
                props.owls = new THREE.Group();
                const owlColors = [0x8B7355, 0x6B5344, 0x5D4037];

                for (let i = 0; i < 4; i++) {
                    const owl = new THREE.Group();
                    const color = owlColors[Math.floor(Math.random() * owlColors.length)];
                    const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });
                    const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

                    // Body
                    const body = new THREE.Mesh(new THREE.SphereGeometry(0.4, 12, 12), mat);
                    body.scale.set(0.8, 1, 0.7);
                    owl.add(body);

                    // Head
                    const head = new THREE.Mesh(new THREE.SphereGeometry(0.3), mat);
                    head.position.y = 0.5;
                    owl.add(head);

                    // Eyes (big owl eyes)
                    [-0.12, 0.12].forEach(ex => {
                        const eyeWhite = new THREE.Mesh(new THREE.SphereGeometry(0.12), whiteMat);
                        eyeWhite.position.set(ex, 0.55, 0.22);
                        owl.add(eyeWhite);

                        const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                        pupil.position.set(ex, 0.55, 0.32);
                        owl.add(pupil);
                    });

                    // Beak
                    const beak = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.12, 4), new THREE.MeshStandardMaterial({ color: 0xffaa00 }));
                    beak.position.set(0, 0.45, 0.28);
                    beak.rotation.x = Math.PI / 2;
                    owl.add(beak);

                    // Wings
                    [-0.4, 0.4].forEach((wx, idx) => {
                        const wing = new THREE.Mesh(new THREE.SphereGeometry(0.25), mat);
                        wing.scale.set(0.3, 0.8, 0.5);
                        wing.position.set(wx, 0.1, 0);
                        owl.add(wing);
                        if (idx === 0) owl.wingL = wing;
                        else owl.wingR = wing;
                    });

                    owl.position.set(
                        (Math.random() - 0.5) * 40,
                        10 + Math.random() * 8,
                        (Math.random() - 0.5) * 30 - 5
                    );
                    owl.scale.set(0.6, 0.6, 0.6);
                    owl.userData.orbitRadius = 8 + Math.random() * 10;
                    owl.userData.orbitSpeed = 0.2 + Math.random() * 0.2;
                    owl.userData.orbitPhase = Math.random() * Math.PI * 2;
                    owl.userData.baseY = owl.position.y;
                    props.owls.add(owl);
                }
                scene.add(props.owls);
            }

            // Ground Decorations (Mushrooms, Rocks, etc.)
            function createGroundDecor() {
                props.groundDecor = new THREE.Group();

                // Mushrooms
                const mushroomColors = [0xff4444, 0xffaa00, 0x8844ff];
                for (let i = 0; i < 15; i++) {
                    const mushroom = new THREE.Group();
                    const x = (Math.random() - 0.5) * 40;
                    const z = (Math.random() - 0.5) * 30;
                    mushroom.position.set(x, -2.9, z);
                    mushroom.scale.set(0.3 + Math.random() * 0.3, 0.3 + Math.random() * 0.3, 0.3 + Math.random() * 0.3);

                    // Stem
                    const stem = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.2, 0.5, 8),
                        new THREE.MeshStandardMaterial({ color: 0xffeedd, roughness: 0.8 })
                    );
                    stem.position.y = 0.25;
                    mushroom.add(stem);

                    // Cap
                    const color = mushroomColors[Math.floor(Math.random() * mushroomColors.length)];
                    const cap = new THREE.Mesh(
                        new THREE.SphereGeometry(0.4, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                        new THREE.MeshStandardMaterial({ color: color, roughness: 0.6 })
                    );
                    cap.position.y = 0.5;
                    mushroom.add(cap);

                    // Spots
                    for (let j = 0; j < 5; j++) {
                        const spot = new THREE.Mesh(
                            new THREE.CircleGeometry(0.06, 8),
                            new THREE.MeshBasicMaterial({ color: 0xffffff })
                        );
                        const angle = Math.random() * Math.PI * 2;
                        const tilt = Math.random() * 0.5;
                        spot.position.set(Math.cos(angle) * 0.3, 0.55 + tilt * 0.1, Math.sin(angle) * 0.3);
                        spot.lookAt(mushroom.position.x, mushroom.position.y + 2, mushroom.position.z);
                        mushroom.add(spot);
                    }
                    props.groundDecor.add(mushroom);
                }

                // Snow-covered rocks
                for (let i = 0; i < 10; i++) {
                    const rock = new THREE.Group();
                    const x = (Math.random() - 0.5) * 45;
                    const z = (Math.random() - 0.5) * 35;
                    rock.position.set(x, -2.85, z);

                    const rockMesh = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(0.3 + Math.random() * 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.9 })
                    );
                    rockMesh.scale.set(1, 0.6, 1);
                    rock.add(rockMesh);

                    // Snow on top
                    const snow = new THREE.Mesh(
                        new THREE.SphereGeometry(0.25, 8, 4, 0, Math.PI * 2, 0, Math.PI / 3),
                        new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 })
                    );
                    snow.position.y = 0.15;
                    rock.add(snow);

                    props.groundDecor.add(rock);
                }
                scene.add(props.groundDecor);
            }


            // ============ SCENE CHARACTERS ============

            // Scene 1: Cute Puppy
            function createPuppy() {
                props.puppy = new THREE.Group();
                props.puppy.position.set(-0.8, -2.8, 1.2);
                const brown = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
                const darkBrown = new THREE.MeshStandardMaterial({ color: 0x5D3A1A, roughness: 0.7 });

                // Shadow Blob (to prevent "floating")
                const shadowGeo = new THREE.CircleGeometry(0.4, 16);
                const shadowMat = new THREE.MeshBasicMaterial({ color: 0x222222, transparent: true, opacity: 0.3 });
                const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                shadow.rotation.x = -Math.PI / 2;
                shadow.position.y = -0.19;
                props.puppy.add(shadow);

                // Body
                const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.3, 0.5, 8, 12), brown);
                body.rotation.z = Math.PI / 2; body.position.y = 0.3;
                body.castShadow = true; props.puppy.add(body);

                // Head
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.28), brown);
                head.position.set(0.45, 0.4, 0); head.castShadow = true;
                props.puppy.add(head); props.puppy.head = head;

                // ... (remaining parts with castShadow)
                const snout = new THREE.Mesh(new THREE.SphereGeometry(0.12), darkBrown);
                snout.position.set(0.65, 0.35, 0); props.puppy.add(snout);
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                nose.position.set(0.75, 0.38, 0); props.puppy.add(nose);
                [-0.08, 0.08].forEach(z => {
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                    eye.position.set(0.6, 0.5, z); props.puppy.add(eye);
                });
                [-0.2, 0.2].forEach(z => {
                    const ear = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8, 0, Math.PI), darkBrown);
                    ear.position.set(0.4, 0.6, z); ear.rotation.x = z > 0 ? 0.5 : -0.5; props.puppy.add(ear);
                });
                const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.06, 0.3), brown);
                tail.position.set(-0.4, 0.4, 0); tail.rotation.z = -0.5;
                props.puppy.add(tail); props.puppy.tail = tail;

                [[-0.15, -0.1], [-0.15, 0.1], [0.2, -0.1], [0.2, 0.1]].forEach(([x, z]) => {
                    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.25), brown);
                    leg.position.set(x, 0.1, z); leg.castShadow = true;
                    props.puppy.add(leg);
                });

                props.puppy.visible = false;
                scene.add(props.puppy);
            }

            // Scene 2: Santa Claus (in sleigh)
            function createSanta() {
                props.santa = new THREE.Group();
                props.santa.position.set(-8, 8, 4);
                props.santa.rotation.y = Math.PI * 1.25; // Face towards camera/center (rotated 180 degrees from before)
                const red = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
                const white = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const skin = new THREE.MeshStandardMaterial({ color: 0xffccaa });

                // Body
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 1.2, 12), red);
                body.position.y = 0.6;
                props.santa.add(body);

                // Belt
                const belt = new THREE.Mesh(new THREE.TorusGeometry(0.55, 0.08, 8, 16), new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
                belt.position.y = 0.4;
                belt.rotation.x = Math.PI / 2;
                props.santa.add(belt);

                // Head
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.35), skin);
                head.position.y = 1.5;
                props.santa.add(head);
                props.santa.head = head;

                // Beard
                const beard = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.5, 8), white);
                beard.position.set(0, 1.2, 0.2);
                beard.rotation.x = 0.3;
                props.santa.add(beard);

                // Hat
                const hatBase = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.38, 0.1, 12), white);
                hatBase.position.y = 1.8;
                props.santa.add(hatBase);
                const hatCone = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.6, 12), red);
                hatCone.position.y = 2.15;
                props.santa.add(hatCone);
                const pomPom = new THREE.Mesh(new THREE.SphereGeometry(0.1), white);
                pomPom.position.set(0.15, 2.4, 0.1);
                props.santa.add(pomPom);

                // ===== SANTA'S FACE =====
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
                const cheekMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, roughness: 0.8 });

                // Eyes (twinkling)
                [-0.12, 0.12].forEach(x => {
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.05), eyeMat);
                    eye.position.set(x, 1.55, 0.3);
                    props.santa.add(eye);
                    // Eye highlights
                    const highlight = new THREE.Mesh(new THREE.SphereGeometry(0.015), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    highlight.position.set(x + 0.02, 1.57, 0.34);
                    props.santa.add(highlight);
                });

                // Eyebrows (bushy white)
                [-0.12, 0.12].forEach(x => {
                    const brow = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.03, 0.03), white);
                    brow.position.set(x, 1.65, 0.28);
                    brow.rotation.z = x > 0 ? -0.2 : 0.2;
                    props.santa.add(brow);
                });

                // Rosy Cheeks
                [-0.2, 0.2].forEach(x => {
                    const cheek = new THREE.Mesh(new THREE.SphereGeometry(0.06), cheekMat);
                    cheek.position.set(x, 1.45, 0.25);
                    props.santa.add(cheek);
                });

                // Nose (round and red)
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.07), new THREE.MeshStandardMaterial({ color: 0xffaaaa }));
                nose.position.set(0, 1.48, 0.35);
                props.santa.add(nose);

                // Jolly Smile (curved line using torus)
                const smileMat = new THREE.MeshBasicMaterial({ color: 0x8B0000 });
                const smile = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.02, 8, 16, Math.PI), smileMat);
                smile.position.set(0, 1.35, 0.28);
                smile.rotation.x = -0.3;
                props.santa.add(smile);

                // Arms
                [-0.6, 0.6].forEach(x => {
                    const arm = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 0.4), red);
                    arm.position.set(x, 0.9, 0);
                    arm.rotation.z = x > 0 ? -0.5 : 0.5;
                    props.santa.add(arm);
                });

                props.santa.visible = false;
                scene.add(props.santa);
            }

            // Scene 3: Gingerbread Man
            function createGingerbread() {
                props.gingerbread = new THREE.Group();
                props.gingerbread.position.set(-5, -2.5, 2);
                const ginger = new THREE.MeshStandardMaterial({ color: 0xCD853F, roughness: 0.8 });
                const icing = new THREE.MeshStandardMaterial({ color: 0xffffff });

                // Body
                const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.25, 0.4, 8, 12), ginger);
                body.position.y = 0.5;
                props.gingerbread.add(body);

                // Head
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.22), ginger);
                head.position.y = 1.0;
                props.gingerbread.add(head);
                props.gingerbread.head = head;

                // Eyes (icing)
                [-0.08, 0.08].forEach(x => {
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04), icing);
                    eye.position.set(x, 1.05, 0.2);
                    props.gingerbread.add(eye);
                });

                // Smile
                const smile = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.02, 8, 12, Math.PI), icing);
                smile.position.set(0, 0.92, 0.2);
                smile.rotation.x = Math.PI;
                props.gingerbread.add(smile);

                // Buttons
                [0.6, 0.45, 0.3].forEach(y => {
                    const btn = new THREE.Mesh(new THREE.SphereGeometry(0.04), icing);
                    btn.position.set(0, y, 0.25);
                    props.gingerbread.add(btn);
                });

                // Arms
                const armL = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.25), ginger);
                armL.position.set(-0.35, 0.6, 0);
                armL.rotation.z = 0.8;
                props.gingerbread.add(armL);
                props.gingerbread.armL = armL;

                const armR = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.25), ginger);
                armR.position.set(0.35, 0.6, 0);
                armR.rotation.z = -0.8;
                props.gingerbread.add(armR);
                props.gingerbread.armR = armR;

                // Legs
                [-0.12, 0.12].forEach(x => {
                    const leg = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.2), ginger);
                    leg.position.set(x, 0.1, 0);
                    props.gingerbread.add(leg);
                });

                props.gingerbread.visible = false;
                scene.add(props.gingerbread);
            }

            // Scene 4: Family Group (3 figures)
            function createFamily() {
                props.family = new THREE.Group();
                props.family.position.set(3, -3, 5);

                const createPerson = (height, color, x, isMe) => {
                    const person = new THREE.Group();
                    person.position.x = x;
                    const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6 });
                    const skin = new THREE.MeshStandardMaterial({ color: 0xffccaa });
                    const black = new THREE.MeshBasicMaterial({ color: 0x000000 });

                    // Body
                    const body = new THREE.Mesh(new THREE.CylinderGeometry(height * 0.18, height * 0.22, height * 0.55), mat);
                    body.position.y = height * 0.28;
                    body.castShadow = true;
                    person.add(body);

                    // Head
                    const head = new THREE.Mesh(new THREE.SphereGeometry(height * 0.14), skin);
                    head.position.y = height * 0.65;
                    head.castShadow = true;
                    person.add(head);

                    // Face Features
                    // Eyes
                    [-0.045, 0.045].forEach(ex => {
                        const eye = new THREE.Mesh(new THREE.SphereGeometry(height * 0.015), black);
                        eye.position.set(ex * height, height * 0.68, height * 0.13);
                        person.add(eye);
                    });
                    // Smile
                    const mouth = new THREE.Mesh(new THREE.TorusGeometry(height * 0.04, height * 0.012, 8, 12, Math.PI), black);
                    mouth.position.set(0, height * 0.63, height * 0.13);
                    mouth.rotation.x = Math.PI;
                    person.add(mouth);

                    // Feet (Boots)
                    [-0.08, 0.08].forEach(fx => {
                        const foot = new THREE.Mesh(new THREE.CapsuleGeometry(height * 0.06, height * 0.12, 4, 8), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                        foot.position.set(fx * height, height * 0.02, height * 0.05);
                        foot.rotation.x = Math.PI / 2;
                        foot.castShadow = true;
                        person.add(foot);
                    });

                    // Scarf
                    const scarf = new THREE.Mesh(new THREE.TorusGeometry(height * 0.1, height * 0.03, 8, 16),
                        new THREE.MeshStandardMaterial({ color: isMe ? 0xff0000 : 0x00aa00 }));
                    scarf.position.y = height * 0.54;
                    scarf.rotation.x = Math.PI / 2;
                    person.add(scarf);

                    return person;
                };

                // "Me" (Tall figure) on the far LEFT
                const me = createPerson(2.2, 0x2c3e50, -1.2, true);
                props.family.add(me);
                // Mom
                props.family.add(createPerson(1.85, 0xc0392b, -0.1, false));
                // Kid
                const kid = createPerson(1.1, 0x27ae60, 0.8, false);
                props.family.add(kid);
                props.family.kid = kid;

                props.family.visible = false;
                scene.add(props.family);
            }

            // Scene 5: Reindeer
            function createReindeer() {
                props.reindeer = new THREE.Group();
                props.reindeer.position.set(3, -2.5, 4);
                const brown = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
                const darkBrown = new THREE.MeshStandardMaterial({ color: 0x5D3A1A });
                const red = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.3 });

                // Body
                const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 0.8, 8, 12), brown);
                body.rotation.z = Math.PI / 2;
                body.position.y = 0.6;
                props.reindeer.add(body);

                // Head
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.25), brown);
                head.position.set(0.7, 0.9, 0);
                props.reindeer.add(head);
                props.reindeer.head = head;

                // Snout
                const snout = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.12, 0.25), brown);
                snout.position.set(0.95, 0.85, 0);
                snout.rotation.z = Math.PI / 2;
                props.reindeer.add(snout);

                // Red Nose (Rudolph!)
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.08), red);
                nose.position.set(1.1, 0.85, 0);
                props.reindeer.add(nose);
                props.reindeer.nose = nose;

                // Eyes
                [-0.1, 0.1].forEach(z => {
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                    eye.position.set(0.85, 1.0, z);
                    props.reindeer.add(eye);
                });

                // Antlers
                [-0.15, 0.15].forEach(z => {
                    const antler = new THREE.Group();
                    antler.position.set(0.6, 1.1, z);

                    const main = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.04, 0.4), darkBrown);
                    main.rotation.z = z > 0 ? 0.3 : -0.3;
                    antler.add(main);

                    // Branches
                    const branch1 = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, 0.2), darkBrown);
                    branch1.position.set(z > 0 ? 0.1 : -0.1, 0.15, 0);
                    branch1.rotation.z = z > 0 ? 0.8 : -0.8;
                    antler.add(branch1);

                    props.reindeer.add(antler);
                });

                // Legs
                [[-0.3, -0.15], [-0.3, 0.15], [0.3, -0.15], [0.3, 0.15]].forEach(([x, z]) => {
                    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.06, 0.5), brown);
                    leg.position.set(x, 0.15, z);
                    props.reindeer.add(leg);
                });

                // Tail
                const tail = new THREE.Mesh(new THREE.SphereGeometry(0.08), brown);
                tail.position.set(-0.6, 0.7, 0);
                props.reindeer.add(tail);

                props.reindeer.visible = false;
                scene.add(props.reindeer);
            }

            // Typing Effect Helper
            function typeWriter(element, text, speed = 50, callback) {
                let i = 0;
                let chars = Array.from(text); // Correctly handles multi-byte characters like emojis
                element.textContent = ""; // Use textContent to preserve all whitespace
                element.classList.add('typing-cursor');
                function type() {
                    if (i < chars.length) {
                        element.textContent += chars[i];
                        i++;
                        setTimeout(type, speed);
                    } else {
                        element.classList.remove('typing-cursor');
                        if (callback) callback();
                    }
                }
                type();
            }

            const poses = {
                wave: () => {
                    elf.userData.isPosing = true;
                    elf.rotation.y %= (Math.PI * 2);
                    // Scene 1: Slow, welcoming entrance
                    gsap.to(elf.position, { x: 0.5, y: -3, z: 6, duration: 1.5, ease: "power2.out", overwrite: true });
                    gsap.to(elf.rotation, { x: 0, y: 0, z: 0, duration: 1.2, ease: "power2.out", overwrite: true });
                    gsap.to(elf.armR.rotation, { z: 2.4, x: 0, duration: 0.6, ease: "back.out", overwrite: true });
                    gsap.to(elf.armR.rotation, { z: 3.0, duration: 0.4, repeat: -1, yoyo: true, delay: 0.6, ease: "sine.inOut" });
                    // EXPRESSION: Friendly welcoming smile
                    if (elf.mouth) {
                        gsap.to(elf.mouth.scale, { x: 1.2, y: 1.2, duration: 0.5, ease: "back.out" });
                        gsap.to(elf.mouth.rotation, { x: Math.PI / 1.1, duration: 0.5 }); // Normal smile
                    }
                },
                lookup: () => {
                    elf.userData.isPosing = true;
                    elf.rotation.y %= (Math.PI * 2);
                    // Scene 2: Gazing at the stars
                    gsap.to(elf.rotation, { y: 0, duration: 1.0, ease: "power2.out", overwrite: true });
                    gsap.to(elf.headJoint.rotation, { x: -0.5, duration: 1.5, repeat: -1, yoyo: true, ease: "sine.inOut" });
                    gsap.to([elf.armL.rotation, elf.armR.rotation], { z: 1.0, x: 0, duration: 0.8, ease: "power2.out", overwrite: true });
                    // EXPRESSION: Wonderous/reflective - smaller, thoughtful mouth
                    if (elf.mouth) {
                        gsap.to(elf.mouth.scale, { x: 0.6, y: 0.8, duration: 0.8, ease: "power2.out" });
                    }

                    // Santa Animation for Scene 2
                    if (props.santa) {
                        gsap.to(props.santa.position, { y: 8.5, duration: 2, repeat: -1, yoyo: true, ease: "sine.inOut" }); // Gentle float
                        // Santa Wave
                        const rightArm = props.santa.children.find(c => c.position.x > 0 && c.geometry && c.geometry.type === 'CapsuleGeometry');
                        if (rightArm) {
                            gsap.to(rightArm.rotation, { z: -0.2, duration: 0.5, ease: "power2.out" });
                            gsap.to(rightArm.rotation, { z: 0.2, duration: 0.5, repeat: -1, yoyo: true, delay: 0.5 });
                        }
                    }
                },
                dance: () => {
                    elf.userData.isPosing = true;
                    elf.rotation.y %= (Math.PI * 2);
                    // Scene 3: Excited about gifts - arms swing FORWARD (negative x)
                    gsap.to(elf.position, { x: -3.5, y: -3, z: 3, duration: 1.2, ease: "power2.out", overwrite: true });
                    gsap.to(elf.rotation, { x: 0, y: Math.PI / 2 + 0.4, z: 0, duration: 1.0, ease: "power2.out", overwrite: true });

                    // Arms forward clap motion (negative x = forward)
                    gsap.to(elf.armL.rotation, { z: 0.3, x: -0.8, duration: 0.3, repeat: -1, yoyo: true, ease: "power1.inOut", overwrite: true });
                    gsap.to(elf.armR.rotation, { z: -0.3, x: -0.8, duration: 0.3, repeat: -1, yoyo: true, delay: 0.15, ease: "power1.inOut", overwrite: true });
                    // EXPRESSION: Big joyful smile - emotional climax!
                    if (elf.mouth) {
                        gsap.to(elf.mouth.scale, { x: 1.5, y: 1.3, duration: 0.6, ease: "elastic.out(1, 0.5)" });
                        gsap.to(elf.mouth.position, { y: 0.12, duration: 0.5 }); // Slightly lower for bigger smile
                    }
                },
                sit: () => {
                    elf.userData.isPosing = true;
                    elf.rotation.y %= (Math.PI * 2);
                    // Scene 4: Cozy sitting in front of snowman
                    gsap.to(elf.rotation, { x: 0, y: 0, z: 0, duration: 1.0, ease: "power2.out", overwrite: true });
                    gsap.to(elf.position, { x: 5, y: -3.5, z: 3.5, duration: 1.2, ease: "power2.out", overwrite: true });

                    // Legs fold forward for sitting
                    gsap.to([elf.legL.rotation, elf.legR.rotation], { x: -1.2, duration: 0.8, ease: "power2.out", overwrite: true });
                    // Gentle leg swing while sitting
                    gsap.to(elf.legL.rotation, { x: -1.0, duration: 1.5, repeat: -1, yoyo: true, delay: 0.8, ease: "sine.inOut" });
                    // EXPRESSION: Content peaceful smile
                    if (elf.mouth) {
                        gsap.to(elf.mouth.scale, { x: 1.0, y: 0.9, duration: 0.8, ease: "power2.out" });
                        gsap.to(elf.mouth.position, { y: 0.15, duration: 0.5 }); // Reset position
                    }
                },
                bow: () => {
                    elf.userData.isPosing = true;
                    elf.rotation.y %= (Math.PI * 2);
                    // Scene 5: Graceful bow facing camera
                    gsap.to(elf.position, { x: 0, y: -3, z: 5, duration: 1.2, ease: "power2.out", overwrite: true });
                    gsap.to(elf.rotation, { x: 0, y: 0, z: 0, duration: 1.0, ease: "power2.out", overwrite: true });
                    gsap.to(elf.rotation, { x: 0.5, duration: 1.2, repeat: -1, yoyo: true, delay: 1.2, ease: "sine.inOut" });
                    // Arms behind back for bow
                    gsap.to([elf.armL.rotation, elf.armR.rotation], { z: 0.5, x: 0.3, duration: 0.8, delay: 0.5, ease: "power2.out", overwrite: true });
                    // EXPRESSION: Proud, grateful smile
                    if (elf.mouth) {
                        gsap.to(elf.mouth.scale, { x: 1.3, y: 1.1, duration: 0.6, ease: "power2.out" });
                        gsap.to(elf.mouth.position, { y: 0.15, duration: 0.5 });
                    }
                },
                reset: () => {
                    elf.userData.isPosing = false;
                    gsap.killTweensOf([elf.position, elf.rotation, elf.armL.rotation, elf.armR.rotation, elf.legL.rotation, elf.legR.rotation, elf.headJoint.rotation]);
                    if (elf.mouth) gsap.killTweensOf([elf.mouth.scale, elf.mouth.position, elf.mouth.rotation]);
                    gsap.to(elf.position, { y: -3, duration: 0.5, ease: "power2.out", overwrite: true });
                    gsap.to(elf.rotation, { x: 0, z: 0, duration: 0.5, ease: "power2.out", overwrite: true });
                    gsap.to([elf.armL.rotation, elf.armR.rotation, elf.legL.rotation, elf.legR.rotation, elf.headJoint.rotation], { x: 0, y: 0, z: 0, duration: 0.5, ease: "power2.out", overwrite: true });
                    // Reset expression
                    if (elf.mouth) {
                        gsap.to(elf.mouth.scale, { x: 1, y: 1, duration: 0.3 });
                        gsap.to(elf.mouth.position, { y: 0.15, duration: 0.3 });
                    }
                }
            };



            function nextScene() {
                if (!appState.isPlaying) return;

                // Check if we just finished the last scene
                if (appState.idx === script.length - 1) {
                    showFinale();
                    return;
                }

                const nextIdx = (appState.idx + 1) % script.length;
                const data = script[nextIdx];
                document.getElementById('current-scene').innerText = nextIdx + 1;

                const overlay = document.getElementById('book-overlay');
                const bL = document.getElementById('book-l');
                const bR = document.getElementById('book-r');

                const tl = gsap.timeline();
                tl.set(overlay, { visibility: 'visible' });

                if (appState.idx === -1) {
                    // FIRST START: Skip closing, update scene and just open
                    gsap.set([bL, bR], { x: "0%", rotateY: 0 });
                    gsap.to('#book-cover-title', { opacity: 0, duration: 0.5 }); // Hide cover title
                    appState.idx = nextIdx;
                    prepareSceneEnvironment(data);
                    tl.to(bL, { rotateY: -110, x: "-100%", duration: 1.5, ease: "power3.inOut", delay: 0.5 })
                        .to(bR, { rotateY: 110, x: "100%", duration: 1.5, ease: "power3.inOut" }, "-=1.5")
                        .to(['#book-spine', '#book-clasp', '#book-ribbon', '#book-spine-glow'], { opacity: 0, duration: 0.8, ease: "power2.inOut" }, "-=1.5") // Fade spine out as pages open
                        .add(() => { startSceneAnimations(data); }, "-=1.0") // Start anims as it opens
                        .set(overlay, { visibility: 'hidden' });
                } else {
                    // NORMAL TRANSITION: Close then Open
                    tl.set(['#book-text-l', '#book-text-r'], { opacity: 1 }) // Show greeting text during transition
                        .fromTo(bL, { x: "-100%", rotateY: -90 }, { x: "0%", rotateY: 0, duration: 1.2, ease: "power3.inOut" })
                        .fromTo(bR, { x: "100%", rotateY: 90 }, { x: "0%", rotateY: 0, duration: 1.2, ease: "power3.inOut" }, "<")
                        .to(['#book-spine', '#book-clasp', '#book-ribbon', '#book-spine-glow'], { opacity: 1, duration: 0.8, ease: "power2.inOut" }, "<") // Fade spine in as pages close
                        .add(() => {
                            appState.idx = nextIdx;
                            prepareSceneEnvironment(data);
                        }, 1.2)
                        .to(bL, { rotateY: -110, x: "-100%", duration: 1.5, ease: "power3.inOut", delay: 0.3 })
                        .to(bR, { rotateY: 110, x: "100%", duration: 1.5, ease: "power3.inOut" }, "-=1.5")
                        .to(['#book-spine', '#book-clasp', '#book-ribbon', '#book-spine-glow'], { opacity: 0, duration: 0.8, ease: "power2.inOut" }, "-=1.5") // Fade spine out again
                        .to(['#book-text-l', '#book-text-r'], { opacity: 0, duration: 0.5 }, "-=1.0") // Hide again as it opens
                        .add(() => { startSceneAnimations(data); }, "-=1.0") // Start anims as it opens
                        .set(overlay, { visibility: 'hidden' });
                }

                gsap.fromTo('#timer', { width: "0%" }, { width: "100%", duration: DURATION, ease: "linear" });
                gsap.delayedCall(DURATION, nextScene);
            }

            function showFinale() {
                appState.isPlaying = false;
                const overlay = document.getElementById('book-overlay');
                const bL = document.getElementById('book-l');
                const bR = document.getElementById('book-r');
                const finale = document.getElementById('finale-msg');
                const tlTextL = document.getElementById('book-text-l');
                const tlTextR = document.getElementById('book-text-r');

                // Clear UI
                gsap.to(['#ui-layer', '.countdown-box', '.scene-indicator', '.hud', '.timer-line'], { opacity: 0, duration: 1 });

                // Final Book Closing
                gsap.timeline()
                    .set(overlay, { visibility: 'visible' })
                    .add(() => {
                        // Change cover text for finale
                        tlTextL.innerText = "The End";
                        tlTextR.innerText = "of the Story";
                    })
                    .fromTo(bL, { x: "-100%", rotateY: -90 }, { x: "0%", rotateY: 0, duration: 2, ease: "power3.inOut" })
                    .fromTo(bR, { x: "100%", rotateY: 90 }, { x: "0%", rotateY: 0, duration: 2, ease: "power3.inOut" }, 0)
                    .to(['#book-spine', '#book-clasp', '#book-ribbon', '#book-spine-glow'], { opacity: 1, duration: 1.5, ease: "power2.inOut" }, 0) // Fade spine in for finale
                    .to(finale, { opacity: 1, duration: 1.5, ease: "power2.inOut" }, "-=0.5")
                    .to([tlTextL, tlTextR], { opacity: 0, duration: 1 }, "-=1");
            }

            function prepareSceneEnvironment(data) {
                document.body.style.background = data.bg;
                if (scene.fog) scene.fog.color.set(data.bg);
                props.stars.visible = (data.bg === "#0c1445");
                props.aurora.visible = (data.bg === "#0c1445");
                gsap.to(camera.position, { x: data.camTarget.x, y: data.camTarget.y, z: data.camTarget.z, duration: 3.5, ease: "power2.inOut" });

                // Reset character visibility
                if (props.puppy) props.puppy.visible = false;
                if (props.santa) props.santa.visible = false;
                if (props.gingerbread) props.gingerbread.visible = false;
                if (props.family) props.family.visible = false;
                if (props.reindeer) props.reindeer.visible = false;

                const sceneIdx = appState.idx;
                if (sceneIdx === 0 && props.puppy) props.puppy.visible = true;
                if (sceneIdx === 1 && props.santa) props.santa.visible = true;
                if (sceneIdx === 2 && props.gingerbread) props.gingerbread.visible = true;
                if (sceneIdx === 3 && props.family) props.family.visible = true;
                if (sceneIdx === 4 && props.reindeer) props.reindeer.visible = true;

                poses.reset();
            }

            function startSceneAnimations(data) {
                const sceneIdx = appState.idx;

                // TEXT ANIMATION - with emotional variation
                const titleEl = document.getElementById('msg-title');
                const subEl = document.getElementById('msg-sub');
                const textWrap = document.getElementById('text-node');
                gsap.killTweensOf(textWrap);
                gsap.set(textWrap, { opacity: 0, y: 30, scale: 0.95 });

                // Scene-specific entrance animations
                if (sceneIdx === 2) {
                    // CLIMAX - Dramatic heartbeat entrance
                    gsap.to(textWrap, { opacity: 1, y: 0, scale: 1, duration: 0.8, ease: "power4.out" });
                    gsap.to(textWrap, { scale: 1.02, duration: 0.5, yoyo: true, repeat: -1, ease: "sine.inOut", delay: 1 }); // Heartbeat
                } else if (sceneIdx === 4) {
                    // ENDING - Grand, hopeful entrance
                    gsap.to(textWrap, { opacity: 1, y: 0, scale: 1, duration: 1.8, ease: "elastic.out(1, 0.5)" });
                } else {
                    gsap.to(textWrap, { opacity: 1, y: 0, scale: 1, duration: 1.2, ease: "back.out(1.2)" });
                }

                // Typing speed varies by emotion
                const typingSpeed = sceneIdx === 2 ? 80 : (sceneIdx === 4 ? 50 : 60); // Slower for emotional scenes
                typeWriter(titleEl, data.title, typingSpeed, () => {
                    setTimeout(() => { typeWriter(subEl, data.sub, sceneIdx === 2 ? 50 : 40); }, sceneIdx === 2 ? 600 : 400);
                });

                gsap.to(textWrap, { y: "-=5", duration: 3, yoyo: true, repeat: -1, ease: "sine.inOut", delay: 1.5 });

                // Scene-specific glow effects
                if (sceneIdx === 2) {
                    // Climax - warm pink/red glow for emotional impact
                    gsap.to(textWrap, { boxShadow: "0 25px 60px rgba(0,0,0,0.5), 0 0 30px rgba(255, 100, 150, 0.4)", duration: 1.5, yoyo: true, repeat: -1, ease: "sine.inOut" });
                } else if (sceneIdx === 4) {
                    // Ending - golden hopeful glow
                    gsap.to(textWrap, { boxShadow: "0 25px 60px rgba(0,0,0,0.5), 0 0 25px rgba(255, 215, 0, 0.5)", duration: 2, yoyo: true, repeat: -1, ease: "sine.inOut" });
                } else {
                    gsap.to(textWrap, { boxShadow: "0 25px 60px rgba(0,0,0,0.5), 0 0 15px rgba(214, 48, 49, 0.2)", duration: 2, yoyo: true, repeat: -1, ease: "sine.inOut" });
                }

                // PHOTO ANIMATION - with emotional variation
                const photoBox = document.getElementById('photo-box');
                const glint = document.getElementById('photo-glint');
                gsap.killTweensOf(photoBox);

                if (sceneIdx === 2) {
                    // CLIMAX - Photo comes closer, more prominent (the person means the world)
                    gsap.set(photoBox, { opacity: 0, scale: 0.6, rotation: 0, y: 80 });
                    gsap.to(photoBox, { opacity: 1, scale: 1.15, rotation: 0, y: -20, duration: 2, ease: "power2.out" });
                    gsap.to(photoBox, { scale: 1.18, duration: 0.8, yoyo: true, repeat: -1, ease: "sine.inOut", delay: 2 }); // Heartbeat effect
                    gsap.to(photoBox, { boxShadow: "0 30px 80px rgba(0,0,0,0.6), 0 0 60px rgba(255,100,150,0.5)", duration: 1.5, yoyo: true, repeat: -1, ease: "sine.inOut" });
                } else if (sceneIdx === 4) {
                    // ENDING - Photo glows golden, feels hopeful
                    gsap.set(photoBox, { opacity: 0, scale: 0.8, rotation: -5, y: 50 });
                    gsap.to(photoBox, { opacity: 1, scale: 1.05, rotation: 0, y: 0, duration: 1.8, ease: "power2.out" });
                    gsap.to(photoBox, { boxShadow: "0 30px 80px rgba(0,0,0,0.6), 0 0 50px rgba(255,215,0,0.6)", duration: 2, yoyo: true, repeat: -1, ease: "sine.inOut" });
                    gsap.to(photoBox, { y: -10, duration: 3, yoyo: true, repeat: -1, ease: "sine.inOut" });
                } else {
                    gsap.set(photoBox, { opacity: 0, scale: 0.8, rotation: -10, y: 50 });
                    gsap.to(photoBox, { opacity: 1, scale: 1, rotation: 0, y: 0, duration: 1.5, ease: "elastic.out(1, 0.6)" });
                    gsap.to(photoBox, { rotation: 2, duration: 4, yoyo: true, repeat: -1, ease: "sine.inOut", delay: 0.5 });
                    gsap.to(photoBox, { y: -15, duration: 4.5, yoyo: true, repeat: -1, ease: "sine.inOut" });
                    gsap.to(photoBox, { scale: 1.03, duration: 3, yoyo: true, repeat: -1, ease: "sine.inOut" });
                    gsap.to(photoBox, { boxShadow: "0 30px 80px rgba(0,0,0,0.6), 0 0 40px rgba(255,215,0,0.4)", duration: 2.5, yoyo: true, repeat: -1, ease: "sine.inOut" });
                }

                gsap.set(glint, { left: "-100%" });
                gsap.to(glint, { left: "200%", duration: 1.5, repeat: -1, repeatDelay: sceneIdx === 2 ? 2 : 3, ease: "power2.inOut" });

                // DECOS
                [1, 2, 3].forEach((n, i) => {
                    const d = document.getElementById(`deco-${n}`); d.innerText = data.decos[i];
                    gsap.killTweensOf(d);
                    gsap.set(d, { scale: 0, opacity: 0, rotation: -45 });
                    gsap.to(d, { scale: sceneIdx === 2 ? 1.4 : 1.2, opacity: 1, delay: 0.5 + i * 0.2, duration: 0.8, ease: "back.out(2)" });
                    gsap.to(d, { rotation: (i % 2 === 0 ? 15 : -15), duration: 2.5 + i, yoyo: true, repeat: -1, ease: "sine.inOut", delay: 1.5 });
                    gsap.to(d, { y: "-=10", duration: 3, yoyo: true, repeat: -1, ease: "sine.inOut", delay: 0.5 + i * 0.5 });
                });

                // CHARACTER ACTIONS
                if (sceneIdx === 0 && props.puppy) {
                    gsap.to(props.puppy.position, { x: 0.2, duration: 2, repeat: -1, yoyo: true, ease: "power1.inOut" });
                    gsap.to(props.puppy.position, { y: -2.6, duration: 0.3, repeat: -1, yoyo: true });
                    gsap.to(props.puppy.tail.rotation, { z: -1.5, duration: 0.15, repeat: -1, yoyo: true });
                }
                if (sceneIdx === 1 && props.santa) {
                    gsap.from(props.santa.scale, { x: 0, y: 0, z: 0, duration: 1, ease: "back.out" });
                    gsap.to(props.santa.rotation, { y: 0.2, duration: 2, repeat: -1, yoyo: true, ease: "sine.inOut" });
                    gsap.to(props.santa.head.rotation, { y: 0.3, duration: 1.2, repeat: -1, yoyo: true });
                }
                if (sceneIdx === 2 && props.gingerbread) {
                    gsap.to(props.gingerbread.position, { y: -2.2, duration: 0.3, repeat: -1, yoyo: true });
                    gsap.to(props.gingerbread.rotation, { y: 0.3, duration: 0.5, repeat: -1, yoyo: true });
                    gsap.to(props.gingerbread.armL.rotation, { z: 1.5, duration: 0.4, repeat: -1, yoyo: true });
                    gsap.to(props.gingerbread.armR.rotation, { z: -1.5, duration: 0.4, repeat: -1, yoyo: true, delay: 0.2 });
                }
                if (sceneIdx === 3 && props.family) {
                    if (props.family.kid) gsap.to(props.family.kid.position, { y: 0.2, duration: 0.5, repeat: -1, yoyo: true });
                }
                if (sceneIdx === 4 && props.reindeer) {
                    gsap.to(props.reindeer.position, { y: -2.3, duration: 0.5, repeat: -1, yoyo: true });
                    gsap.to(props.reindeer.head.rotation, { y: 0.2, duration: 1, repeat: -1, yoyo: true });
                    if (props.reindeer.nose) gsap.to(props.reindeer.nose.material, { emissiveIntensity: 1.0, duration: 0.5, repeat: -1, yoyo: true });
                }

                if (poses[data.charPose]) poses[data.charPose]();
            }

            document.getElementById('go-btn').onclick = () => {
                document.getElementById('bgm').play().catch(() => { });
                gsap.to('#start-overlay', {
                    opacity: 0, duration: 0.7, onComplete: () => {
                        document.getElementById('start-overlay').style.display = 'none';
                        document.getElementById('countdown-box').style.display = 'flex';
                        document.getElementById('scene-indicator').style.display = 'block';
                        document.getElementById('total-scenes').innerText = script.length;
                        init3D(); appState.isPlaying = true;
                        countdownInterval = setInterval(updateCountdown, 1000);
                        nextScene();
                    }
                });
            };

            document.getElementById('btn-pause').onclick = () => {
                appState.isPlaying = !appState.isPlaying;
                document.getElementById('btn-pause').innerText = appState.isPlaying ? "‚è∏" : "‚ñ∂";
                if (appState.isPlaying) { countdownInterval = setInterval(updateCountdown, 1000); nextScene(); } else { clearInterval(countdownInterval); }
            };

            // Anticipation / "Thinking" Peek Logic
            function initAnticipation() {
                const bL = document.getElementById('book-l');
                const bR = document.getElementById('book-r');
                const glow = document.getElementById('book-spine-glow');

                const peek = () => {
                    if (appState.idx !== -1) return; // Only on home screen

                    const tl = gsap.timeline();
                    // 1. Shiver of anticipation
                    // 1. Shiver of anticipation
                    tl.to([bL, bR], { x: (i) => i === 0 ? -1 : 1, duration: 0.1, repeat: 5, yoyo: true })
                        // 2. The Peek / Tease
                        .to(bL, { x: -8, duration: 0.8, ease: "power2.out" }, "+=0.1")
                        .to(bR, { x: 8, duration: 0.8, ease: "power2.out" }, "<")
                        .to(glow, { opacity: 0.8, scaleX: 3, duration: 0.8 }, "<")
                        // 3. Close back up
                        .to([bL, bR], { x: 0, duration: 1.2, ease: "power3.inOut" })
                        .to(glow, { opacity: 0, scaleX: 1, duration: 1.2 }, "-=1.2");

                    // Schedule next peek (5 to 12 seconds later)
                    gsap.delayedCall(Math.random() * 7 + 5, peek);
                };

                // Start the cycle
                gsap.delayedCall(4, peek);
            }

            document.getElementById('btn-mute').onclick = () => {
                const a = document.getElementById('bgm'); a.muted = !a.muted;
                document.getElementById('btn-mute').innerText = a.muted ? "üîá" : "üîä";
            };

            function animate() {
                requestAnimationFrame(animate);
                if (!renderer) return;
                const time = clock.getElapsedTime();
                if (props.snow) {
                    const p = props.snow.children[0].geometry.attributes.position.array;
                    for (let i = 1; i < p.length; i += 3) { p[i] -= 0.04; p[i - 1] += Math.sin(time + i) * 0.002; if (p[i] < -3) p[i] = 32; }
                    props.snow.children[0].geometry.attributes.position.needsUpdate = true;
                }
                if (props.floatingOrns) props.floatingOrns.children.forEach(o => { o.position.y += Math.sin(time * o.userData.speed + o.userData.phase) * 0.008; o.rotation.y += 0.01; o.rotation.x += 0.005; });
                if (props.sparkles) props.sparkles.children.forEach(s => { s.scale.setScalar(0.5 + Math.sin(time * s.userData.speed + s.userData.phase) * 0.5); s.rotation.y += 0.03; });
                if (props.stars && props.stars.visible) props.stars.children.forEach(s => { s.scale.setScalar(0.8 + Math.sin(time * s.userData.twinkleSpeed + s.userData.phase) * 0.3); });
                if (christmasTree && christmasTree.star) christmasTree.star.scale.setScalar(1 + Math.sin(time * 2) * 0.1);
                presents.forEach(p => { p.position.y = p.userData.baseY + Math.sin(time * 1.5 + p.userData.phase) * 0.08; p.rotation.y = Math.sin(time * 0.8 + p.userData.phase) * 0.05; });
                if (props.candyCanes) props.candyCanes.children.forEach(c => { c.rotation.z = Math.sin(time * 1.2 + c.userData.phase) * 0.08; });
                if (props.stringLights) props.stringLights.children.forEach((b, i) => { b.material.emissiveIntensity = 0.5 + Math.sin(time * 3 + b.userData.phase) * 0.5; });
                if (snowman) snowman.rotation.y = Math.sin(time * 0.3) * 0.05;
                trees.forEach(t => { t.rotation.z = Math.sin(time * 0.5 + t.userData.phase) * 0.02; });
                if (props.sleigh) {
                    props.sleigh.position.x += 0.06; props.sleigh.position.y = 18 + Math.sin(time * 1.5) * 1.5; props.sleigh.rotation.z = Math.sin(time * 1.5) * 0.1;
                    if (props.sleigh.position.x > 35) props.sleigh.position.x = -35;
                    const spk = new THREE.Mesh(new THREE.OctahedronGeometry(0.12), new THREE.MeshBasicMaterial({ color: 0xffddaa, transparent: true, opacity: 0.8 }));
                    spk.position.copy(props.sleigh.position); spk.position.x -= 2; props.sleighTrail.add(spk);
                    gsap.to(spk.scale, { x: 0, y: 0, z: 0, duration: 2, onComplete: () => props.sleighTrail.remove(spk) });
                }
                if (props.aurora && props.aurora.visible) {
                    const pos = props.aurora.children[0].geometry.attributes.position.array;
                    for (let i = 0; i < pos.length; i += 3) { pos[i + 2] = Math.sin(time + pos[i] * 0.1) * 2; }
                    props.aurora.children[0].geometry.attributes.position.needsUpdate = true;
                }

                // ============ NEW LIFE ELEMENT ANIMATIONS ============

                // Floating Lanterns
                if (props.lanterns) {
                    props.lanterns.children.forEach(lantern => {
                        lantern.position.y += Math.sin(time * lantern.userData.speed + lantern.userData.phase) * 0.005;
                        lantern.position.x += lantern.userData.driftX;
                        lantern.rotation.y = Math.sin(time * 0.3 + lantern.userData.phase) * 0.2;
                        lantern.rotation.z = Math.sin(time * 0.5 + lantern.userData.phase) * 0.1;
                        // Reset lanterns that drift too far
                        if (lantern.position.x > 30) lantern.position.x = -30;
                        if (lantern.position.x < -30) lantern.position.x = 30;
                    });
                }

                // Hopping Bunnies
                if (props.bunnies) {
                    props.bunnies.children.forEach(bunny => {
                        const hopHeight = Math.abs(Math.sin(time * bunny.userData.hopSpeed + bunny.userData.hopPhase));
                        bunny.position.y = -2.8 + hopHeight * 0.3;
                        // Move forward while hopping
                        bunny.position.x += Math.cos(bunny.userData.direction) * hopHeight * 0.02;
                        bunny.position.z += Math.sin(bunny.userData.direction) * hopHeight * 0.02;
                        bunny.rotation.y = bunny.userData.direction;
                        // Squash and stretch
                        bunny.scale.y = 0.4 - hopHeight * 0.05;
                        bunny.scale.x = bunny.scale.z = 0.4 + hopHeight * 0.03;
                        // Keep in bounds
                        if (Math.abs(bunny.position.x) > 20 || Math.abs(bunny.position.z) > 15) {
                            bunny.userData.direction += Math.PI;
                        }
                    });
                }

                // Fireflies
                if (props.fireflies) {
                    props.fireflies.children.forEach(ff => {
                        ff.position.x += Math.sin(time * ff.userData.speed + ff.userData.phase) * 0.02;
                        ff.position.y += Math.cos(time * ff.userData.speed * 0.7 + ff.userData.phase) * 0.015;
                        ff.position.z += Math.sin(time * ff.userData.speed * 0.5 + ff.userData.phase + 1) * 0.02;
                        // Pulsing glow
                        ff.material.opacity = 0.4 + Math.sin(time * 3 + ff.userData.phase) * 0.4;
                        ff.scale.setScalar(0.8 + Math.sin(time * 4 + ff.userData.phase) * 0.3);
                    });
                }

                // Flying Owls
                if (props.owls) {
                    props.owls.children.forEach(owl => {
                        const angle = time * owl.userData.orbitSpeed + owl.userData.orbitPhase;
                        owl.position.x = Math.cos(angle) * owl.userData.orbitRadius;
                        owl.position.z = Math.sin(angle) * owl.userData.orbitRadius - 10;
                        owl.position.y = owl.userData.baseY + Math.sin(time * 0.8) * 0.5;
                        owl.rotation.y = -angle + Math.PI / 2;
                        // Wing flapping
                        if (owl.wingL) owl.wingL.rotation.z = Math.sin(time * 6) * 0.4;
                        if (owl.wingR) owl.wingR.rotation.z = -Math.sin(time * 6) * 0.4;
                    });
                }

                // Elf Walking Logic
                if (elf && !elf.userData.isPosing) {
                    const walkSpeed = 0.8;
                    const radius = 3.5;
                    const angle = time * 0.4;

                    // Circular path around the center
                    elf.position.x = Math.cos(angle) * radius;
                    elf.position.z = Math.sin(angle) * radius + 2; // Offset slightly
                    elf.rotation.y = (-angle) % (Math.PI * 2); // Normalized rotation to prevent spinning fast on transitions

                    // Bobbing motion
                    elf.position.y = -3 + Math.abs(Math.sin(time * 3)) * 0.15;

                    // Leg Swing
                    elf.legL.rotation.x = Math.sin(time * 5) * 0.5;
                    elf.legR.rotation.x = Math.sin(time * 5 + Math.PI) * 0.5;

                    // Arm Swing
                    elf.armL.rotation.x = Math.sin(time * 5 + Math.PI) * 0.3;
                    elf.armR.rotation.x = Math.sin(time * 5) * 0.3;
                }

                camera.position.y += Math.sin(time * 0.4) * 0.003; camera.position.x += Math.cos(time * 0.3) * 0.002;
                renderer.render(scene, camera);
            }
            window.addEventListener('resize', () => { if (!camera || !renderer) return; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            // Start anticipation peeks immediately while on home screen
            initAnticipation();

            // Create light intro snow
            const introContainer = document.getElementById('intro-sparkles');
            for (let i = 0; i < 25; i++) {
                const s = document.createElement('div');
                s.className = 'snowflake-intro';
                s.style.left = Math.random() * 100 + '%';
                s.style.top = Math.random() * 100 + '%';
                s.style.width = s.style.height = (Math.random() * 5 + 2) + 'px';
                s.style.animationDelay = (Math.random() * 10) + 's';
                s.style.animationDuration = (Math.random() * 5 + 10) + 's';
                introContainer.appendChild(s);
            }

            // Unlock audio on interaction
            // Unlock audio on interaction
            const unlockAudio = () => {
                document.getElementById('bgm').play().catch(() => { });
                document.removeEventListener('click', unlockAudio);
            };
            document.addEventListener('click', unlockAudio);

        })();
    </script>
</body>

</html>